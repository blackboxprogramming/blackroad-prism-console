#!/usr/bin/env python3
import os
import json
import subprocess
from http.server import BaseHTTPRequestHandler, HTTPServer
from urllib.parse import urlparse

ROOT = "/home/pi/portal"
HOST, PORT = "127.0.0.1", 8787
TOKEN_PATH = os.path.join(ROOT, "configs", "api.token")
if not os.path.exists(TOKEN_PATH):
    raise SystemExit(f"missing token file: {TOKEN_PATH}")
with open(TOKEN_PATH, "r", encoding="utf-8") as fh:
    TOKEN = fh.read().strip()
ENABLE_PSBT_API = os.environ.get("ENABLE_PSBT_API", "0") == "1"


def run(cmd):
    proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=False)
    return proc.returncode, proc.stdout, proc.stderr


def json_response(handler, status, obj):
    data = json.dumps(obj).encode()
    handler.send_response(status)
    handler.send_header("Content-Type", "application/json")
    handler.send_header("Content-Length", str(len(data)))
    handler.end_headers()
    handler.wfile.write(data)


class Handler(BaseHTTPRequestHandler):
    def _authed(self):
        auth = self.headers.get("Authorization", "")
        return auth == f"Bearer {TOKEN}"

    def do_GET(self):
        if not self._authed():
            return json_response(self, 401, {"error": "unauthorized"})
        parsed = urlparse(self.path)
        if parsed.path == "/health":
            btc = os.path.join(ROOT, "proofs", "aura-proof.json")
            ltc = os.path.join(ROOT, "proofs", "ltc-proof.json")

            def load_amount(path, keypath):
                if not os.path.exists(path):
                    return None
                try:
                    with open(path, "r", encoding="utf-8") as fp:
                        data = json.load(fp)
                    for key in keypath.split("."):
                        if isinstance(data, dict):
                            data = data.get(key)
                        else:
                            data = None
                        if data is None:
                            break
                    return data
                except Exception:
                    return None

            res = {
                "btc": load_amount(btc, "scantxoutset.total_amount"),
                "ltc": load_amount(ltc, "scantxoutset.total_amount"),
            }
            return json_response(self, 200, res)
        if parsed.path == "/proof":
            rc, _out, err = run([os.path.join(ROOT, "bin", "portal"), "proof", os.path.join(ROOT, "configs", "raw.descriptor")])
            if rc != 0:
                return json_response(self, 500, {"error": "proof failed", "stderr": err})
            try:
                with open(os.path.join(ROOT, "proofs", "aura-proof.json"), "r", encoding="utf-8") as fh:
                    return json_response(self, 200, json.load(fh))
            except Exception as exc:  # pylint: disable=broad-except
                return json_response(self, 500, {"error": str(exc)})
        return json_response(self, 404, {"error": "not found"})

    def do_POST(self):
        if not self._authed():
            return json_response(self, 401, {"error": "unauthorized"})
        parsed = urlparse(self.path)
        length = int(self.headers.get("Content-Length", "0") or 0)
        body = self.rfile.read(length).decode() if length else ""
        try:
            payload = json.loads(body) if body else {}
        except json.JSONDecodeError:
            payload = {}
        if parsed.path == "/psbt/new":
            if not ENABLE_PSBT_API:
                return json_response(self, 403, {"error": "psbt api disabled"})
            label = payload.get("label", "api_tx")
            outputs = payload.get("outputs", [])
            fee = int(payload.get("fee", 3))
            outspath = os.path.join(ROOT, "configs", f"{label}.outputs.json")
            with open(outspath, "w", encoding="utf-8") as fh:
                json.dump(outputs, fh)
            rc, _out, err = run([os.path.join(ROOT, "bin", "portal"), "psbt:new", label, outspath, str(fee)])
            if rc != 0:
                return json_response(self, 500, {"error": "psbt failed", "stderr": err})
            return json_response(self, 200, {"psbt": os.path.join(ROOT, "psbts", f"{label}.psbt")})
        return json_response(self, 404, {"error": "not found"})

    def log_message(self, fmt, *args):  # pylint: disable=unused-argument
        return


if __name__ == "__main__":
    httpd = HTTPServer((HOST, PORT), Handler)
    print(f"portal-rest listening on http://{HOST}:{PORT} (token in {TOKEN_PATH})")
    httpd.serve_forever()
