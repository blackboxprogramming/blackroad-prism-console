name: Auto mention teams

on:
  pull_request_target:
    types: [opened, reopened, synchronize, ready_for_review]

permissions:
  contents: read
  pull-requests: write

jobs:
  route:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    steps:
      - name: Skip if opted out
        id: optout
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo
            const number = context.payload.pull_request.number
            const {data: pr} = await github.rest.pulls.get({owner, repo, pull_number: number})
            const hasNoMentions = pr.labels?.some(l => l.name === "no-mentions")
            return hasNoMentions ? core.setOutput("skip","true") : null
      - name: Checkout default branch
        if: steps.optout.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch }}
      - name: Calculate mentions
        id: calc
        if: steps.optout.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const fs = require('fs');

            function loadConfig() {
              let raw;
              try {
                raw = fs.readFileSync('.github/mention-routes.yml', 'utf8').trim();
              } catch (error) {
                if (error && error.code === 'ENOENT') {
                  return { routes: [], always: [] };
                }
                throw error;
              }
              if (!raw) {
                return { routes: [], always: [] };
              }
              try {
                return JSON.parse(raw);
              } catch (err) {
                throw new Error(`Failed to parse .github/mention-routes.yml: ${err.message}`);
              }
            }

            function matches(pattern, file) {
              if (pattern === '**') return true;
              if (pattern.endsWith('/**')) {
                const prefix = pattern.slice(0, -3);
                return file.startsWith(prefix);
              }
              if (pattern.startsWith('**/')) {
                const suffix = pattern.slice(3);
                return file.endsWith(suffix);
              }
              if (pattern.includes('*')) {
                const escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp('^' + escaped.replace(/\*+/g, '.*') + '$');
                return regex.test(file);
              }
              return file === pattern;
            }

            const config = loadConfig();
            const routes = Array.isArray(config.routes) ? config.routes : [];
            const always = Array.isArray(config.always)
              ? config.always.map(value => String(value).trim()).filter(Boolean)
              : [];
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: number,
              per_page: 100
            });

            const filenames = files.map(file => file.filename);
            const mentions = new Set(always);
            const teamSlugs = new Set();

            for (const route of routes) {
              if (!route || !route.patterns || !route.mention) continue;
              const patterns = (Array.isArray(route.patterns) ? route.patterns : [route.patterns])
                .map(pattern => String(pattern).trim())
                .filter(Boolean);
              if (!patterns.length) continue;
              const hit = filenames.some(file => patterns.some(pattern => matches(pattern, file)));
              if (hit) {
                const mentionValue = String(route.mention).trim();
                if (mentionValue) {
                  mentions.add(mentionValue);
                }
              }
            }

            const ordered = Array.from(mentions).filter(Boolean);
            const mentionLine = ordered.join(' ');

            for (const mention of ordered) {
              if (mention.startsWith('@')) {
                const parts = mention.slice(1).split('/');
                if (parts.length === 2 && parts[1]) {
                  teamSlugs.add(parts[1].trim());
                }
              }
            }

            core.setOutput('MENTIONS', mentionLine);
            core.setOutput('TEAM_REVIEWERS', Array.from(teamSlugs).join(','));

      - name: Keyword-based mentions
        id: kw
        if: steps.optout.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo
            const number = context.payload.pull_request.number
            const {data: pr} = await github.rest.pulls.get({owner, repo, pull_number: number})
            const hay = ((pr.title || "") + " " + (pr.body || "")).toLowerCase()

            const table = [
              {keywords:["blackroad","br"], mention:"@blackboxprogramming/blackroad"},
              {keywords:["prism"],           mention:"@blackboxprogramming/prism"},
              {keywords:["migrations","sql"],mention:"@blackboxprogramming/data"},
            ]

            const hits = new Set()
            for (const row of table) {
              if (row.keywords.some(k => hay.includes(k))) hits.add(row.mention)
            }
            core.setOutput("mentions", Array.from(hits).join(" "))

      - name: Merge mentions
        if: steps.optout.outputs.skip != 'true'
        id: merge
        env:
          PATH_MENTIONS: ${{ steps.calc.outputs.MENTIONS }}
          KEYWORD_MENTIONS: ${{ steps.kw.outputs.mentions }}
        run: |
          python - <<'PY'
          import os
          from pathlib import Path

          path_mentions = os.getenv("PATH_MENTIONS", "").split()
          keyword_mentions = os.getenv("KEYWORD_MENTIONS", "").split()

          seen = set()
          ordered = []
          for mention in path_mentions + keyword_mentions:
              mention = mention.strip()
              if not mention or mention in seen:
                  continue
              seen.add(mention)
              ordered.append(mention)

          all_mentions = " ".join(ordered)
          team_slugs = sorted({m.split('/', 1)[1] for m in ordered if m.startswith('@') and '/' in m})

          output = Path(os.environ["GITHUB_OUTPUT"])
          with output.open("a", encoding="utf-8") as fh:
              fh.write(f"ALL={all_mentions}\n")
              fh.write(f"TEAM_REVIEWERS={','.join(team_slugs)}\n")
          PY

      - name: Create or update a single comment (only if changed)
        if: steps.optout.outputs.skip != 'true' && steps.merge.outputs.ALL != ''
        uses: actions/github-script@v7
        env:
          MENTIONS: ${{ steps.merge.outputs.ALL }}
        with:
          script: |
            const mentions = (process.env.MENTIONS || '').trim();
            if (!mentions) return;
            const {owner, repo} = context.repo;
            const number = context.payload.pull_request.number;
            const marker = "(Automated based on changed paths.)";
            const newBody = `Routing to: ${mentions}\n\n${marker}`;

            const {data: comments} = await github.rest.issues.listComments({owner, repo, issue_number: number, per_page:100});
            const mine = comments.find(c => c.user?.type==="Bot" && c.body?.includes(marker));

            if (!mine) {
              await github.rest.issues.createComment({owner, repo, issue_number: number, body: newBody});
            } else if (mine.body !== newBody) {
              await github.rest.issues.updateComment({owner, repo, comment_id: mine.id, body: newBody});
            }

      - name: Request team reviewers
        if: steps.optout.outputs.skip != 'true' && steps.merge.outputs.TEAM_REVIEWERS != ''
        uses: actions/github-script@v7
        env:
          TEAM_REVIEWERS: ${{ steps.merge.outputs.TEAM_REVIEWERS }}
        with:
          script: |
            const teams = (process.env.TEAM_REVIEWERS || '')
              .split(',')
              .map(t => t.trim())
              .filter(Boolean);
            if (!teams.length) return;
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;
            await github.rest.pulls.requestReviewers({
              owner,
              repo,
              pull_number: number,
              team_reviewers: teams
            });
