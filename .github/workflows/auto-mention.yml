name: Auto mention teams

on:
  pull_request_target:
    types: [opened, reopened, synchronize, ready_for_review]

permissions:
  contents: read
  pull-requests: write

jobs:
  route:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    steps:
      - name: Checkout default branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.repository.default_branch }}
      - name: Calculate mentions
        id: calc
        uses: actions/github-script@v7
        with:
          result-encoding: string
          script: |
            const fs = require('fs');

            function loadConfig() {
              let raw;
              try {
                raw = fs.readFileSync('.github/mention-routes.yml', 'utf8').trim();
              } catch (error) {
                if (error && error.code === 'ENOENT') {
                  return { routes: [], always: [] };
                }
                throw error;
              }
              if (!raw) {
                return { routes: [], always: [] };
              }
              const config = parseConfig(raw);
              if (!config || typeof config !== 'object') {
                throw new Error('Failed to parse .github/mention-routes.yml: invalid structure');
              }
              return config;
            }

            function parseConfig(raw) {
              try {
                return JSON.parse(raw);
              } catch (jsonError) {
                return parseSimpleYAML(raw);
              }
            }

            function parseSimpleYAML(raw) {
              const lines = raw.split(/\r?\n/);
              const root = {};
              const stack = [{ indent: -1, type: 'object', value: root }];

              const pendingContext = key => ({
                indent: key.indent,
                type: 'pending',
                container: key.container,
                key: key.key,
                value: null
              });

              function ensureContainer(context, indent, line) {
                if (context.type !== 'pending') {
                  return context;
                }
                const isArray = line.trim().startsWith('- ');
                const nextValue = isArray ? [] : {};
                context.container[context.key] = nextValue;
                context.type = isArray ? 'array' : 'object';
                context.value = nextValue;
                return context;
              }

              function parseScalar(value) {
                if (value === undefined || value === null) return null;
                if (value === '') return null;
                if (value === '[]') return [];
                if (value === '{}') return {};
                if (value === 'true') return true;
                if (value === 'false') return false;
                if (value === 'null') return null;
                if (/^[+-]?\d+(\.\d+)?$/.test(value)) {
                  return Number(value);
                }
                const first = value[0];
                const last = value[value.length - 1];
                if ((first === '"' && last === '"') || first === '[' || first === '{') {
                  return JSON.parse(value);
                }
                return value;
              }

              for (const rawLine of lines) {
                if (!rawLine.trim() || rawLine.trim().startsWith('#')) {
                  continue;
                }
                const indent = rawLine.match(/^\s*/)[0].length;
                while (stack.length > 1 && indent <= stack[stack.length - 1].indent) {
                  stack.pop();
                }
                if (!stack.length) {
                  throw new Error('Invalid YAML structure in .github/mention-routes.yml');
                }
                let parent = stack[stack.length - 1];
                parent = ensureContainer(parent, indent, rawLine);
                stack[stack.length - 1] = parent;

                const line = rawLine.trim();
                if (line.startsWith('- ')) {
                  if (parent.type !== 'array') {
                    throw new Error('YAML array item without array context');
                  }
                  const content = line.slice(2).trim();
                  if (!content) {
                    const obj = {};
                    parent.value.push(obj);
                    stack.push({ indent, type: 'object', value: obj });
                    continue;
                  }
                  const colonIndex = content.indexOf(':');
                  if (colonIndex === -1) {
                    parent.value.push(parseScalar(content));
                    continue;
                  }
                  const key = content.slice(0, colonIndex).trim();
                  const valuePart = content.slice(colonIndex + 1).trim();
                  const obj = {};
                  if (valuePart) {
                    obj[key] = parseScalar(valuePart);
                  } else {
                    obj[key] = null;
                  }
                  parent.value.push(obj);
                  stack.push({ indent, type: 'object', value: obj });
                  if (!valuePart) {
                    stack.push(pendingContext({ indent, container: obj, key }));
                  }
                  continue;
                }

                const colonIndex = line.indexOf(':');
                if (colonIndex === -1) {
                  throw new Error('Invalid YAML line: ' + line);
                }
                const key = line.slice(0, colonIndex).trim();
                const valuePart = line.slice(colonIndex + 1).trim();
                const target = parent.type === 'array' ? parent.value[parent.value.length - 1] : parent.value;
                if (parent.type === 'array' && (!target || typeof target !== 'object')) {
                  throw new Error('Cannot assign property to non-object array item');
                }
                const container = parent.type === 'array' ? target : parent.value;
                if (valuePart) {
                  container[key] = parseScalar(valuePart);
                } else {
                  const pending = { indent, container, key };
                  container[key] = null;
                  stack.push(pendingContext(pending));
                }
              }

              return root;
            }

            function matches(pattern, file) {
              if (pattern === '**') return true;
              if (pattern.endsWith('/**')) {
                const prefix = pattern.slice(0, -3);
                return file.startsWith(prefix);
              }
              if (pattern.startsWith('**/')) {
                const suffix = pattern.slice(3);
                return file.endsWith(suffix);
              }
              if (pattern.includes('*')) {
                const escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
                const regex = new RegExp('^' + escaped.replace(/\*+/g, '.*') + '$');
                return regex.test(file);
              }
              return file === pattern;
            }

            const config = loadConfig();
            const routes = Array.isArray(config.routes) ? config.routes : [];
            const always = Array.isArray(config.always)
              ? config.always.map(value => String(value).trim()).filter(Boolean)
              : [];
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: number,
              per_page: 100
            });

            const filenames = files.map(file => file.filename);
            const mentions = new Set(always);
            const teamSlugs = new Set();

            for (const route of routes) {
              if (!route || !route.patterns || !route.mention) continue;
              const patterns = (Array.isArray(route.patterns) ? route.patterns : [route.patterns])
                .map(pattern => String(pattern).trim())
                .filter(Boolean);
              if (!patterns.length) continue;
              const hit = filenames.some(file => patterns.some(pattern => matches(pattern, file)));
              if (hit) {
                const mentionValue = String(route.mention).trim();
                if (mentionValue) {
                  mentions.add(mentionValue);
                }
              }
            }

            const ordered = Array.from(mentions).filter(Boolean);
            const mentionLine = ordered.join(' ');

            for (const mention of ordered) {
              if (mention.startsWith('@')) {
                const parts = mention.slice(1).split('/');
                if (parts.length === 2 && parts[1]) {
                  teamSlugs.add(parts[1].trim());
                }
              }
            }

            core.setOutput('MENTIONS', mentionLine);
            core.setOutput('TEAM_REVIEWERS', Array.from(teamSlugs).join(','));

      - name: Add mention comment
        if: ${{ steps.calc.outputs.MENTIONS != '' }}
        uses: actions/github-script@v7
        env:
          MENTIONS: ${{ steps.calc.outputs.MENTIONS }}
        with:
          script: |
            const mentions = (process.env.MENTIONS || '').trim();
            if (!mentions) return;
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: number,
              body: `Routing ${mentions} based on changed files.`
            });

      - name: Request team reviewers
        if: ${{ steps.calc.outputs.MENTIONS != '' && steps.calc.outputs.TEAM_REVIEWERS != '' }}
        uses: actions/github-script@v7
        env:
          TEAM_REVIEWERS: ${{ steps.calc.outputs.TEAM_REVIEWERS }}
        with:
          script: |
            const teams = (process.env.TEAM_REVIEWERS || '')
              .split(',')
              .map(t => t.trim())
              .filter(Boolean);
            if (!teams.length) return;
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;
            await github.rest.pulls.requestReviewers({
              owner,
              repo,
              pull_number: number,
              team_reviewers: teams
            });
