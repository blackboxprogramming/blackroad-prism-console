import JSZip from "jszip";
import { randomUUID } from "crypto";

const UNITY_VERSION = "2022.3.17f1";
const UNITY_REVISION = "2022.3.17f1 (9fc6c861743b)";
const DEFAULT_PROJECT_NAME = "BlackRoadUnityPrototype";
const DEFAULT_SCENE_NAME = "SampleScene";
const DEFAULT_SUMMARY = "Prototype Unity project generated by the BlackRoad exporter stub.";
const MAX_NAME_LENGTH = 64;
const MAX_FEATURES = 12;

function sanitizeProjectName(raw) {
  const candidate = String(raw ?? "").trim();
  if (!candidate) {
    return DEFAULT_PROJECT_NAME;
  }
  const cleaned = candidate
    .replace(/[^A-Za-z0-9 _-]+/g, " ")
    .replace(/\s+/g, " ")
    .trim()
    .replace(/\s+/g, "-");
  if (!cleaned) {
    return DEFAULT_PROJECT_NAME;
  }
  return cleaned.slice(0, MAX_NAME_LENGTH);
}

function sanitizeSceneName(raw) {
  const candidate = String(raw ?? "").trim();
  if (!candidate) {
    return DEFAULT_SCENE_NAME;
  }
  const cleaned = candidate
    .replace(/[^A-Za-z0-9]+/g, " ")
    .replace(/\s+/g, " ")
    .trim();
  if (!cleaned) {
    return DEFAULT_SCENE_NAME;
  }
  return toPascalCase(cleaned).slice(0, MAX_NAME_LENGTH) || DEFAULT_SCENE_NAME;
}

function sanitizeSummary(raw) {
  if (raw === undefined || raw === null) {
    return DEFAULT_SUMMARY;
  }
  const summary = String(raw).trim();
  return summary || DEFAULT_SUMMARY;
}

function sanitizeFeatures(raw) {
  if (!Array.isArray(raw)) {
    return [];
  }
  const cleaned = raw
    .map((item) => String(item ?? "").trim())
    .filter(Boolean)
    .slice(0, MAX_FEATURES);
  return cleaned;
}

function toPascalCase(value, fallback = "UnityExportedValue") {
  const parts = String(value ?? "")
    .split(/[^A-Za-z0-9]+/)
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  if (!parts.length) {
    return fallback;
  }
  return parts.join("");
}

function escapeForCSharp(value) {
  return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function escapeForYaml(value) {
  return value.replace(/"/g, '\\"');
}

function createGuid() {
  return randomUUID().replace(/-/g, "").toLowerCase();
}

function wrapFolder(folder, prefix, manifest) {
  return {
    file(name, contents) {
      folder.file(name, contents);
      manifest.push(`${prefix}${name}`);
    },
    folder(name) {
      return wrapFolder(folder.folder(name), `${prefix}${name}/`, manifest);
    },
  };
}

function buildReadme({ projectName, summary, sceneName, features, timestamp }) {
  const featureSection = features.length
    ? features.map((line) => `- ${line}`).join("\n")
    : "- Add gameplay beats or systems you want to explore.";
  return `# ${projectName}\n\n` +
    `Generated ${timestamp.toISOString()} via the BlackRoad Unity exporter stub.\n\n` +
    `## Summary\n${summary}\n\n` +
    `## Primary Scene\n- Assets/Scenes/${sceneName}.unity\n\n` +
    `## Suggested Next Steps\n${featureSection}\n\n` +
    `## Usage\n` +
    `1. Unzip the archive.\n` +
    `2. Open the folder in Unity ${UNITY_VERSION}.\n` +
    `3. Load **${sceneName}.unity** to begin iterating.\n` +
    `4. Replace the generated script with production-ready logic once gameplay direction is locked.`;
}

function buildScene({ sceneName, scriptGuid, summary, features }) {
  const escapedSummary = escapeForYaml(summary);
  const featureLines = features.length ? features.map((f) => `        - ${escapeForYaml(f)}`).join("\n") : "        - Define your first mechanic.";
  return `%YAML 1.1\n` +
    `%TAG !u! tag:unity3d.com,2011:\n` +
    `--- !u!1 &1\n` +
    `GameObject:\n` +
    `  m_ObjectHideFlags: 0\n` +
    `  m_CorrespondingSourceObject: {fileID: 0}\n` +
    `  m_PrefabInstance: {fileID: 0}\n` +
    `  m_PrefabAsset: {fileID: 0}\n` +
    `  serializedVersion: 6\n` +
    `  m_Component:\n` +
    `  - component: {fileID: 2}\n` +
    `  - component: {fileID: 3}\n` +
    `  m_Layer: 0\n` +
    `  m_Name: ${sceneName}\n` +
    `  m_TagString: Untagged\n` +
    `  m_Icon: {fileID: 0}\n` +
    `  m_NavMeshLayer: 0\n` +
    `  m_StaticEditorFlags: 0\n` +
    `  m_IsActive: 1\n` +
    `--- !u!4 &2\n` +
    `Transform:\n` +
    `  m_ObjectHideFlags: 0\n` +
    `  m_CorrespondingSourceObject: {fileID: 0}\n` +
    `  m_PrefabInstance: {fileID: 0}\n` +
    `  m_PrefabAsset: {fileID: 0}\n` +
    `  m_GameObject: {fileID: 1}\n` +
    `  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}\n` +
    `  m_LocalPosition: {x: 0, y: 0, z: 0}\n` +
    `  m_LocalScale: {x: 1, y: 1, z: 1}\n` +
    `  m_ConstrainProportionsScale: 0\n` +
    `  m_Children: []\n` +
    `  m_Father: {fileID: 0}\n` +
    `  m_RootOrder: 0\n` +
    `  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}\n` +
    `--- !u!114 &3\n` +
    `MonoBehaviour:\n` +
    `  m_ObjectHideFlags: 0\n` +
    `  m_CorrespondingSourceObject: {fileID: 0}\n` +
    `  m_PrefabInstance: {fileID: 0}\n` +
    `  m_PrefabAsset: {fileID: 0}\n` +
    `  m_GameObject: {fileID: 1}\n` +
    `  m_Enabled: 1\n` +
    `  m_EditorHideFlags: 0\n` +
    `  m_Script: {fileID: 11500000, guid: ${scriptGuid}, type: 3}\n` +
    `  m_Name: ${sceneName} Director\n` +
    `  m_EditorClassIdentifier: \n` +
    `  summary: "${escapedSummary}"\n` +
    `  features:\n${featureLines}\n` +
    `  lastUpdated: "${new Date().toISOString()}"\n` +
    `  readyForPlaytest: 0`;
}

function buildSceneMeta(guid) {
  return `fileFormatVersion: 2\n` +
    `guid: ${guid}\n` +
    `DefaultImporter:\n` +
    `  externalObjects: {}\n` +
    `  userData: \n` +
    `  assetBundleName: \n` +
    `  assetBundleVariant: `;
}

function buildScript({ namespaceName, className, summary, features, sceneName }) {
  const featureLines = features.length
    ? features.map((line) => `            \"${escapeForCSharp(line)}\"`).join(",\n")
    : "            \"Define your first mechanic\"";
  return `using System.Collections.Generic;\nusing UnityEngine;\n\nnamespace ${namespaceName}\n{\n    public class ${className} : MonoBehaviour\n    {\n        [TextArea(2, 6)]\n        public string Summary = \"${escapeForCSharp(summary)}\";\n\n        [SerializeField]\n        private string[] plannedBeats = new string[]\n        {\n${featureLines}\n        };\n\n        public IReadOnlyList<string> PlannedBeats => plannedBeats;\n\n        private void Start()\n        {\n            Debug.Log($"[${className}] Bootstrapped scene '${escapeForCSharp(sceneName)}'.");\n        }\n\n        public void LogPlan()\n        {\n            foreach (var beat in plannedBeats)\n            {\n                Debug.Log($"[${className}] TODO: {beat}");\n            }\n        }\n    }\n}`;
}

function buildScriptMeta(guid) {
  return `fileFormatVersion: 2\n` +
    `guid: ${guid}\n` +
    `MonoImporter:\n` +
    `  externalObjects: {}\n` +
    `  serializedVersion: 2\n` +
    `  defaultReferences: []\n` +
    `  executionOrder: 0\n` +
    `  icon: {instanceID: 0}\n` +
    `  userData: \n` +
    `  assetBundleName: \n` +
    `  assetBundleVariant: `;
}

function buildManifestJson() {
  return JSON.stringify(
    {
      dependencies: {
        "com.unity.cinemachine": "2.8.9",
        "com.unity.inputsystem": "1.6.3",
        "com.unity.textmeshpro": "3.0.6",
        "com.unity.timeline": "1.7.6",
        "com.unity.test-framework": "1.4.5",
      },
    },
    null,
    2,
  );
}

function buildProjectSettings(projectName) {
  return `%YAML 1.1\n` +
    `%TAG !u! tag:unity3d.com,2011:\n` +
    `--- !u!129 &1\n` +
    `PlayerSettings:\n` +
    `  m_ObjectHideFlags: 0\n` +
    `  serializedVersion: 23\n` +
    `  productName: ${projectName}\n` +
    `  companyName: BlackRoad\n` +
    `  bundleVersion: 0.1.0\n` +
    `  defaultScreenWidth: 1920\n` +
    `  defaultScreenHeight: 1080\n` +
    `  runInBackground: 1\n` +
    `  allowFullscreenSwitch: 1\n` +
    `  splashScreenLogos: []\n` +
    `  m_StereoRenderingPath: 0\n` +
    `  m_ActiveColorSpace: 0\n` +
    `  defaultIsNativeResolution: 1`;
}

function buildEditorBuildSettings({ sceneName, sceneGuid }) {
  return `%YAML 1.1\n` +
    `%TAG !u! tag:unity3d.com,2011:\n` +
    `--- !u!1045 &1\n` +
    `EditorBuildSettings:\n` +
    `  m_ObjectHideFlags: 0\n` +
    `  serializedVersion: 2\n` +
    `  m_Scenes:\n` +
    `  - enabled: 1\n` +
    `    path: Assets/Scenes/${sceneName}.unity\n` +
    `    guid: ${sceneGuid}\n` +
    `  m_configObjects: {}`;
}

function buildProjectVersion() {
  return `m_EditorVersion: ${UNITY_VERSION}\n` +
    `m_EditorVersionWithRevision: ${UNITY_REVISION}`;
}

export async function createUnityProjectArchive(options = {}) {
  const projectName = sanitizeProjectName(options.projectName);
  const sceneName = sanitizeSceneName(options.sceneName);
  const summary = sanitizeSummary(options.summary);
  const features = sanitizeFeatures(options.features);
  const namespaceName = `${toPascalCase(projectName, "BlackRoad")}.Generated`;
  const className = `${sceneName}Director`;
  const scriptGuid = createGuid();
  const sceneGuid = createGuid();
  const timestamp = new Date();

  const zip = new JSZip();
  const manifest = [];
  const root = wrapFolder(zip.folder(projectName), `${projectName}/`, manifest);

  root.file("README.md", buildReadme({ projectName, summary, sceneName, features, timestamp }));

  const projectSettings = root.folder("ProjectSettings");
  projectSettings.file("ProjectSettings.asset", buildProjectSettings(projectName));
  projectSettings.file("EditorBuildSettings.asset", buildEditorBuildSettings({ sceneName, sceneGuid }));
  projectSettings.file("ProjectVersion.txt", buildProjectVersion());

  const packages = root.folder("Packages");
  packages.file("manifest.json", buildManifestJson());

  const assets = root.folder("Assets");
  const scenes = assets.folder("Scenes");
  scenes.file(`${sceneName}.unity`, buildScene({ sceneName, scriptGuid, summary, features }));
  scenes.file(`${sceneName}.unity.meta`, buildSceneMeta(sceneGuid));

  const scripts = assets.folder("Scripts");
  scripts.file(`${className}.cs`, buildScript({ namespaceName, className, summary, features, sceneName }));
  scripts.file(`${className}.cs.meta`, buildScriptMeta(scriptGuid));

  const metadata = {
    projectName,
    sceneName,
    scriptClass: className,
    unityVersion: UNITY_VERSION,
    generatedAt: timestamp.toISOString(),
    featureCount: features.length,
  };

  const archiveBuffer = await zip.generateAsync({
    type: "nodebuffer",
    compression: "DEFLATE",
    compressionOptions: { level: 9 },
  });

  return {
    buffer: archiveBuffer,
    zipName: `${projectName}-${timestamp.toISOString().replace(/[:.]/g, "-")}.zip`,
    fileManifest: manifest.sort(),
    metadata,
  };
}
