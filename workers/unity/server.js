import express from "express";
import { execFile } from "child_process";
import {
  mkdtemp,
  mkdir,
  writeFile,
  rm,
  stat
} from "fs/promises";
import os from "os";
import path from "path";
import { promisify } from "util";

const execFileAsync = promisify(execFile);

class ExportError extends Error {
  constructor(message, status = 500) {
    super(message);
    this.status = status;
  }
}

const app = express();
app.use(express.json({ limit: "1mb" }));

app.post("/export", async (req, res) => {
  try {
    const { projectName, scenes, description } = req.body ?? {};
    const safeProjectName = sanitizeProjectName(projectName);
    const safeScenes = normalizeScenes(scenes);
    const exportInfo = await createUnityProject({
      projectName: safeProjectName,
      scenes: safeScenes,
      description: typeof description === "string" ? description.trim() : undefined
    });
    res.json({
      ok: true,
      ...exportInfo
    });
  } catch (error) {
    const status = error instanceof ExportError ? error.status : 500;
    const message = error instanceof Error ? error.message : "Unknown error";
    console.error("Unity export failed", error);
    res.status(status).json({ ok: false, error: message });
  }
});

const port = process.env.PORT || 3000;
app.listen(port, () => console.log("unity exporter listening on", port));

function sanitizeProjectName(name) {
  if (typeof name !== "string") {
    return "BlackRoadUnityProject";
  }
  const cleaned = name
    .trim()
    .replace(/[^A-Za-z0-9 _-]/g, "")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^[-_]+|[-_]+$/g, "");
  return cleaned ? cleaned.slice(0, 64) : "BlackRoadUnityProject";
}

function normalizeScenes(input) {
  if (input === undefined) {
    return ["MainScene"];
  }
  if (!Array.isArray(input)) {
    throw new ExportError("`scenes` must be an array of names", 400);
  }
  const sanitized = input
    .map((scene) => (typeof scene === "string" ? scene : ""))
    .map((scene) =>
      scene
        .trim()
        .replace(/[^A-Za-z0-9 _-]/g, "")
        .replace(/\s+/g, "_")
        .replace(/_+/g, "_")
        .replace(/^[_-]+|[_-]+$/g, "")
    )
    .filter(Boolean);
  const uniqueScenes = Array.from(new Set(sanitized)).slice(0, 20);
  return uniqueScenes.length > 0 ? uniqueScenes : ["MainScene"];
}

async function createUnityProject({ projectName, scenes, description }) {
  const tempRoot = await mkdtemp(path.join(os.tmpdir(), "unity-export-"));
  const projectRoot = path.join(tempRoot, projectName);
  const scenesDir = path.join(projectRoot, "Assets", "Scenes");
  const projectSettingsDir = path.join(projectRoot, "ProjectSettings");
  const packagesDir = path.join(projectRoot, "Packages");

  try {
    await mkdir(scenesDir, { recursive: true });
    await mkdir(projectSettingsDir, { recursive: true });
    await mkdir(packagesDir, { recursive: true });

    await Promise.all([
      writeReadme(projectRoot, projectName, description),
      writeBuildSettings(projectSettingsDir, scenes),
      writeProjectVersion(projectSettingsDir),
      writeProjectSettings(projectSettingsDir),
      writeManifest(packagesDir)
    ]);

    await Promise.all(
      scenes.map((sceneName, index) =>
        writeScene(path.join(scenesDir, `${sceneName}.unity`), sceneName, index)
      )
    );

    const downloadsDir = path.join(process.cwd(), "downloads");
    await mkdir(downloadsDir, { recursive: true });
    const zipPath = path.join(
      downloadsDir,
      `${projectName}-${Date.now()}.zip`
    );

    try {
      await execFileAsync("zip", ["-rq", zipPath, projectName], {
        cwd: tempRoot
      });
    } catch (error) {
      throw new ExportError(
        "Failed to bundle Unity project. Ensure the `zip` utility is available.",
        500
      );
    }

    const fileStats = await stat(zipPath);
    return {
      path: zipPath,
      projectName,
      scenes,
      size: fileStats.size,
      createdAt: new Date().toISOString()
    };
  } finally {
    await rm(tempRoot, { recursive: true, force: true });
  }
}

async function writeReadme(projectRoot, projectName, description) {
  const contents = [`# ${projectName}`, "", description?.trim() || "Unity project scaffold generated by BlackRoad.", "", "## Getting Started", "1. Open the project in Unity 2022.3 LTS or newer.", "2. Review the generated scenes under `Assets/Scenes`.", "3. Update project settings and packages to match your team's standards."].join("\n");
  await writeFile(path.join(projectRoot, "README.md"), contents, "utf8");
}

async function writeBuildSettings(projectSettingsDir, scenes) {
  const entries = scenes
    .map(
      (scene) =>
        "  - enabled: 1\n" +
        `    path: Assets/Scenes/${scene}.unity\n` +
        "    guid: 00000000000000000000000000000000"
    )
    .join("\n");
  const contents =
    "%YAML 1.1\n" +
    "%TAG !u! tag:unity3d.com,2011:\n" +
    "--- !u!1045 &1\n" +
    "EditorBuildSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "  serializedVersion: 2\n" +
    "  m_Scenes:\n" +
    entries +
    "\n  m_configObjects: {}\n";
  await writeFile(
    path.join(projectSettingsDir, "EditorBuildSettings.asset"),
    contents,
    "utf8"
  );
}

async function writeProjectVersion(projectSettingsDir) {
  const contents = [
    "m_EditorVersion: 2022.3.21f1",
    "m_EditorVersionWithRevision: 2022.3.21f1 (revision 6c5b472a2d91)"
  ].join("\n");
  await writeFile(
    path.join(projectSettingsDir, "ProjectVersion.txt"),
    contents,
    "utf8"
  );
}

async function writeProjectSettings(projectSettingsDir) {
  const contents =
    "%YAML 1.1\n" +
    "%TAG !u! tag:unity3d.com,2011:\n" +
    "--- !u!129 &1\n" +
    "PlayerSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "  serializedVersion: 23\n" +
    "  productName: BlackRoad Prototype\n" +
    "  companyName: BlackRoad Labs\n" +
    "  defaultScreenWidth: 1920\n" +
    "  defaultScreenHeight: 1080\n" +
    "  fullscreenMode: 1\n" +
    "  defaultScreenOrientation: 4\n" +
    "  displayResolutionDialog: 1\n" +
    "  targetDevice: 2\n" +
    "  usePlayerLog: 1\n" +
    "  forceSingleInstance: 0\n" +
    "  resizableWindow: 1\n" +
    "  useMacAppStoreValidation: 0\n" +
    "  protectGraphicsMemory: 0\n" +
    "  visibleInBackground: 1\n" +
    "  allowFullscreenSwitch: 1\n" +
    "  runInBackground: 1\n" +
    "  captureSingleScreen: 0\n";
  await writeFile(
    path.join(projectSettingsDir, "ProjectSettings.asset"),
    contents,
    "utf8"
  );
}

async function writeManifest(packagesDir) {
  const manifest = {
    dependencies: {
      "com.unity.collab-proxy": "1.17.7",
      "com.unity.ide.rider": "3.0.24",
      "com.unity.ide.visualstudio": "2.0.22",
      "com.unity.ide.vscode": "1.2.5",
      "com.unity.render-pipelines.universal": "14.0.10",
      "com.unity.test-framework": "1.3.9",
      "com.unity.textmeshpro": "3.0.6",
      "com.unity.timeline": "1.7.5",
      "com.unity.ugui": "1.0.0",
      "com.unity.modules.ai": "1.0.0",
      "com.unity.modules.animation": "1.0.0",
      "com.unity.modules.audio": "1.0.0",
      "com.unity.modules.director": "1.0.0",
      "com.unity.modules.imageconversion": "1.0.0",
      "com.unity.modules.jsonserialize": "1.0.0",
      "com.unity.modules.particlesystem": "1.0.0",
      "com.unity.modules.physics": "1.0.0",
      "com.unity.modules.physics2d": "1.0.0",
      "com.unity.modules.tilemap": "1.0.0",
      "com.unity.modules.ui": "1.0.0",
      "com.unity.modules.uielements": "1.0.0",
      "com.unity.modules.unitywebrequest": "1.0.0",
      "com.unity.modules.video": "1.0.0"
    }
  };
  await writeFile(
    path.join(packagesDir, "manifest.json"),
    JSON.stringify(manifest, null, 2),
    "utf8"
  );
}

async function writeScene(scenePath, sceneName, index) {
  const contents =
    "%YAML 1.1\n" +
    "%TAG !u! tag:unity3d.com,2011:\n" +
    "--- !u!29 &1\n" +
    "SceneSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "--- !u!104 &2\n" +
    "RenderSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "--- !u!157 &3\n" +
    "LightmapSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "--- !u!196 &4\n" +
    "NavMeshSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "--- !u!1 &1000\n" +
    "GameObject:\n" +
    `  m_Name: ${sceneName}\n` +
    "  m_Component:\n" +
    "  - component: {fileID: 2000}\n" +
    "  m_Layer: 0\n" +
    "  m_IsActive: 1\n" +
    "--- !u!4 &2000\n" +
    "Transform:\n" +
    "  m_GameObject: {fileID: 1000}\n" +
    "  m_LocalPosition: {x: 0, y: 0, z: 0}\n" +
    "  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}\n" +
    "  m_LocalScale: {x: 1, y: 1, z: 1}\n" +
    `  m_RootOrder: ${index}\n` +
    "  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}\n";
  await writeFile(scenePath, contents, "utf8");
}
