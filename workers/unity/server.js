import express from "express";
import { execFile } from "child_process";
import {
  mkdtemp,
  mkdir,
  rm,
  writeFile
} from "fs/promises";
import os from "os";
import path from "path";
import { promisify } from "util";

const execFileAsync = promisify(execFile);

const app = express();
app.use(express.json());

const DEFAULT_PROJECT_NAME = "BlackRoadUnitySample";
const DEFAULT_SCENE_NAME = "SampleScene";
const DEFAULT_SCRIPT_NAME = "HelloBlackRoad";

const DEFAULT_SCRIPT = `using UnityEngine;

public class HelloBlackRoad : MonoBehaviour
{
    void Start()
    {
        Debug.Log("BlackRoad Unity exporter generated project ready!");
    }
}
`;

const DEFAULT_SCENE = `# BlackRoad Unity Scene Placeholder
# Open in Unity and add objects to build out your world.
`;

const PROJECT_VERSION = `m_EditorVersion: 2022.3.15f1
m_EditorVersionWithRevision: 2022.3.15f1 (bce4550a1dad)
`;

const PACKAGE_MANIFEST = JSON.stringify(
  {
    dependencies: {
      "com.unity.collab-proxy": "1.17.7",
      "com.unity.ide.rider": "3.0.21",
      "com.unity.ide.visualstudio": "2.0.22",
      "com.unity.ide.vscode": "1.2.5",
      "com.unity.test-framework": "1.1.33",
      "com.unity.textmeshpro": "3.0.6",
      "com.unity.timeline": "1.7.4",
      "com.unity.ugui": "1.0.0",
      "com.unity.modules.ai": "1.0.0",
      "com.unity.modules.animation": "1.0.0",
      "com.unity.modules.audio": "1.0.0",
      "com.unity.modules.imgui": "1.0.0",
      "com.unity.modules.physics": "1.0.0",
      "com.unity.modules.physics2d": "1.0.0",
      "com.unity.modules.tilemap": "1.0.0",
      "com.unity.modules.ui": "1.0.0",
      "com.unity.modules.unitywebrequest": "1.0.0"
    }
  },
  null,
  2
);

function sanitizeFolderName(name, fallback) {
  const normalized =
    (name ?? "")
      .toString()
      .trim()
      .replace(/[^A-Za-z0-9-_]+/g, "-") || fallback;
  return normalized.length ? normalized : fallback;
}

function sanitizeIdentifier(name, fallback) {
  const normalized =
    (name ?? "")
      .toString()
      .trim()
      .replace(/[^A-Za-z0-9_]+/g, "") || fallback;
  return normalized.length ? normalized : fallback;
}

async function createUnityTemplate(projectRoot, options) {
  const {
    projectName,
    sceneName,
    scriptName,
    scriptContents,
    sceneContents
  } = options;

  const assetsDir = path.join(projectRoot, "Assets");
  const scriptsDir = path.join(assetsDir, "Scripts");
  const scenesDir = path.join(assetsDir, "Scenes");
  const packagesDir = path.join(projectRoot, "Packages");
  const settingsDir = path.join(projectRoot, "ProjectSettings");

  await Promise.all([
    mkdir(scriptsDir, { recursive: true }),
    mkdir(scenesDir, { recursive: true }),
    mkdir(packagesDir, { recursive: true }),
    mkdir(settingsDir, { recursive: true })
  ]);

  const scriptFile = path.join(scriptsDir, `${scriptName}.cs`);
  const sceneFile = path.join(scenesDir, `${sceneName}.unity`);
  const packageManifest = path.join(packagesDir, "manifest.json");
  const projectVersion = path.join(settingsDir, "ProjectVersion.txt");
  const projectReadme = path.join(projectRoot, "README.md");

  await Promise.all([
    writeFile(scriptFile, scriptContents ?? DEFAULT_SCRIPT, "utf8"),
    writeFile(sceneFile, sceneContents ?? DEFAULT_SCENE, "utf8"),
    writeFile(packageManifest, PACKAGE_MANIFEST, "utf8"),
    writeFile(projectVersion, PROJECT_VERSION, "utf8"),
    writeFile(
      projectReadme,
      `# ${projectName}\n\nGenerated by the BlackRoad Unity exporter.\n`,
      "utf8"
    )
  ]);
}

app.post("/export", async (req, res) => {
  const body = req.body ?? {};

  const projectName = sanitizeFolderName(
    body.projectName,
    DEFAULT_PROJECT_NAME
  );
  const sceneName = sanitizeFolderName(body.sceneName, DEFAULT_SCENE_NAME);
  const scriptName = sanitizeIdentifier(
    body.scriptName,
    DEFAULT_SCRIPT_NAME
  );

  const outDir = path.join(process.cwd(), "downloads");
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
  const archiveName = `${projectName}-${timestamp}.zip`;
  const zipPath = path.join(outDir, archiveName);

  let tempRoot;
  try {
    await mkdir(outDir, { recursive: true });

    tempRoot = await mkdtemp(path.join(os.tmpdir(), "unity-exporter-"));
    const projectRoot = path.join(tempRoot, projectName);
    await mkdir(projectRoot, { recursive: true });

    await createUnityTemplate(projectRoot, {
      projectName,
      sceneName,
      scriptName,
      scriptContents: body.scriptContents,
      sceneContents: body.sceneContents
    });

    await rm(zipPath, { force: true });
    await execFileAsync("zip", ["-r", zipPath, projectName], {
      cwd: tempRoot
    });

    res.json({
      ok: true,
      projectName,
      sceneName,
      scriptName,
      path: zipPath
    });
  } catch (error) {
    console.error("unity exporter error", error);
    res.status(500).json({ ok: false, error: String(error) });
  } finally {
    if (tempRoot) {
      try {
        await rm(tempRoot, { recursive: true, force: true });
      } catch (cleanupError) {
        console.warn("failed to clean up temp directory", cleanupError);
      }
    }
  }
});

const port = process.env.PORT || 3000;
app.listen(port, () => console.log("unity exporter listening on", port));
