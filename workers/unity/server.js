import express from "express";
import {
  mkdir,
  mkdtemp,
  rename,
  rm,
  writeFile,
} from "fs/promises";
import path from "path";
import { tmpdir } from "os";
import { promisify } from "util";
import { execFile } from "child_process";
import { randomUUID } from "crypto";

const execFileAsync = promisify(execFile);

const app = express();
app.use(express.json());

const DEFAULT_PROJECT_NAME = "BlackRoadUnity";
const DEFAULT_DESCRIPTION =
  "Starter Unity project generated by the BlackRoad exporter.";
const DEFAULT_SCENES = ["SampleScene"];
const UNITY_VERSION = "2022.3.36f1";
const UNITY_VERSION_WITH_REVISION = `${UNITY_VERSION} (000000000000)`;

const sanitizeProjectName = (name) => {
  if (typeof name !== "string") return DEFAULT_PROJECT_NAME;
  const trimmed = name.trim();
  if (!trimmed) return DEFAULT_PROJECT_NAME;
  const normalized = trimmed
    .replace(/[^A-Za-z0-9-_\s]/g, "-")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "");
  return normalized ? normalized.slice(0, 64) : DEFAULT_PROJECT_NAME;
};

const sanitizeSceneName = (name) => {
  if (typeof name !== "string") return null;
  const trimmed = name.trim();
  if (!trimmed) return null;
  const normalized = trimmed
    .replace(/[^A-Za-z0-9-_\s]/g, "-")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "");
  return normalized || null;
};

const normalizeScenes = (scenes) => {
  if (scenes === undefined) return DEFAULT_SCENES;
  if (!Array.isArray(scenes)) return null;
  const deduped = new Set();
  for (const entry of scenes) {
    let candidate = entry;
    if (entry && typeof entry === "object" && typeof entry.name === "string") {
      candidate = entry.name;
    }
    const sanitized = sanitizeSceneName(candidate);
    if (sanitized) {
      deduped.add(sanitized);
    }
  }
  return deduped.size > 0 ? Array.from(deduped) : DEFAULT_SCENES;
};

const projectReadme = (projectName, description, scenes) => {
  const sceneList = scenes.map((scene) => `- Assets/Scenes/${scene}.unity`).join("\n");
  return `# ${projectName}\n\n${description}\n\n## Included Scenes\n${sceneList}\n\nGenerated on ${new Date().toISOString()} by the Unity exporter service.`;
};

const manifestJson = `{
  "dependencies": {
    "com.unity.collab-proxy": "2.0.5",
    "com.unity.ide.rider": "3.0.24",
    "com.unity.ide.visualstudio": "2.0.22",
    "com.unity.test-framework": "1.3.9",
    "com.unity.textmeshpro": "3.0.6",
    "com.unity.timeline": "1.7.5",
    "com.unity.ugui": "1.0.0",
    "com.unity.visualscripting": "1.9.4"
  }
}`;

const projectVersionFile = () =>
  `m_EditorVersion: ${UNITY_VERSION}\nm_EditorVersionWithRevision: ${UNITY_VERSION_WITH_REVISION}\n`; // newline at end of file expected by Unity

const editorBuildSettings = (scenes) => {
  const sceneEntries = scenes
    .map(
      (scene) => `  - enabled: 1\n    path: Assets/Scenes/${scene}.unity\n    guid: ${randomUUID().replace(/-/g, "")}`,
    )
    .join("\n");
  return `%YAML 1.1\n%TAG !u! tag:unity3d.com,2011:\n--- !u!1045 &1\nEditorBuildSettings:\n  m_ObjectHideFlags: 0\n  serializedVersion: 2\n  m_Scenes:\n${sceneEntries}\n  m_configObjects: {}\n`;
};

const defaultSceneContent = (scene) => `// ${scene}.unity\n// Placeholder scene generated by the BlackRoad Unity exporter.\n// Open this project in Unity to replace it with a real scene.\n`;

app.post("/export", async (req, res) => {
  const {
    projectName: requestedProjectName,
    description = DEFAULT_DESCRIPTION,
    scenes: requestedScenes,
  } = req.body ?? {};

  const projectName = sanitizeProjectName(requestedProjectName);
  const scenes = normalizeScenes(requestedScenes);

  if (!scenes) {
    res
      .status(400)
      .json({ ok: false, error: "`scenes` must be an array of names or { name } objects." });
    return;
  }

  let stagingRoot;
  try {
    const downloadsDir = path.join(process.cwd(), "downloads");
    await mkdir(downloadsDir, { recursive: true });

    stagingRoot = await mkdtemp(path.join(tmpdir(), "unity-export-"));
    const projectRoot = path.join(stagingRoot, projectName);
    await mkdir(projectRoot, { recursive: true });

    const createdFiles = [];
    const writeRelativeFile = async (relativePath, contents) => {
      const targetPath = path.join(projectRoot, relativePath);
      await mkdir(path.dirname(targetPath), { recursive: true });
      await writeFile(targetPath, contents, "utf8");
      createdFiles.push(relativePath.replace(/\\/g, "/"));
    };

    await writeRelativeFile("README.md", projectReadme(projectName, description, scenes));
    await writeRelativeFile("Packages/manifest.json", `${manifestJson}\n`);
    await writeRelativeFile("ProjectSettings/ProjectVersion.txt", projectVersionFile());
    await writeRelativeFile(
      "ProjectSettings/EditorBuildSettings.asset",
      editorBuildSettings(scenes),
    );
    await writeRelativeFile(
      "Assets/Scripts/README.md",
      `# Scripts\n\nAdd your gameplay scripts in this folder.\n\nGenerated scenes:\n${scenes
        .map((scene) => `- ${scene}`)
        .join("\n")}\n`,
    );

    for (const scene of scenes) {
      await writeRelativeFile(`Assets/Scenes/${scene}.unity`, defaultSceneContent(scene));
    }

    const zipTempDir = stagingRoot;
    const zipTempPath = path.join(zipTempDir, `${projectName}.zip`);
    const zipTargetPath = path.join(
      downloadsDir,
      `${projectName}-${Date.now().toString(36)}.zip`,
    );

    try {
      await execFileAsync("zip", ["-r", zipTempPath, projectName], {
        cwd: zipTempDir,
      });
    } catch (error) {
      const stderr = error?.stderr?.toString() ?? "";
      throw new Error(`Failed to create zip archive: ${error.message || error}. ${stderr}`);
    }

    await rename(zipTempPath, zipTargetPath);

    res.json({
      ok: true,
      projectName,
      path: zipTargetPath,
      files: createdFiles.sort(),
    });
  } catch (error) {
    console.error("Unity export failed", error);
    res.status(500).json({ ok: false, error: error?.message || String(error) });
  } finally {
    if (stagingRoot) {
      try {
        await rm(stagingRoot, { recursive: true, force: true });
      } catch (cleanupError) {
        console.warn("Failed to clean up staging directory", cleanupError);
      }
    }
  }
});

const port = process.env.PORT || 3000;
app.listen(port, () => console.log("unity exporter listening on", port));
