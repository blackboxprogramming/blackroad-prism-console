import express from "express";
import path from "path";
import { exportUnityProject } from "./src/exporter.js";
import { mkdir, writeFile } from "fs/promises";
import { execFile } from "child_process";
import {
  mkdtemp,
  mkdir,
  rm,
  writeFile
} from "fs/promises";
import os from "os";
import path from "path";
import { promisify } from "util";

const execFileAsync = promisify(execFile);
import archiver from "archiver";
import { mkdir } from "fs/promises";
import { createWriteStream } from "fs";
import archiver from "archiver";
import crypto from "crypto";
import { createWriteStream } from "fs";
import { mkdir } from "fs/promises";
import path from "path";
import crypto from "crypto";
import { buildUnityTemplate } from "./template.js";
import {
  mkdir,
  mkdtemp,
  rename,
  rm,
  writeFile,
} from "fs/promises";
import path from "path";
import { tmpdir } from "os";
import { promisify } from "util";
import { execFile } from "child_process";
import { randomUUID } from "crypto";

const execFileAsync = promisify(execFile);

const app = express();
app.use(express.json({ limit: "2mb" }));

app.post("/export", async (req, res) => {
  try {
    const result = await exportUnityProject({
      ...req.body,
      outputDir: path.join(process.cwd(), "downloads"),
    });
    res.json({
      ok: true,
      path: result.zipPath,
      projectFolder: result.projectFolder,
      bytes: result.bytes,
      files: result.files,
      metadata: result.metadata,
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    res.status(500).json({ ok: false, error: message });
app.post("/export", async (_req, res) => {
const DEFAULT_PROJECT_NAME = "BlackRoadUnitySample";
const DEFAULT_SCENE_NAME = "SampleScene";
const DEFAULT_SCRIPT_NAME = "HelloBlackRoad";

function createDefaultScript(scriptName) {
  return `using UnityEngine;

public class ${scriptName} : MonoBehaviour
{
    void Start()
    {
        Debug.Log("BlackRoad Unity exporter generated project ready!");
    }
}
`;
}

const DEFAULT_SCENE = `# BlackRoad Unity Scene Placeholder
# Open in Unity and add objects to build out your world.
`;

const PROJECT_VERSION = `m_EditorVersion: 2022.3.15f1
m_EditorVersionWithRevision: 2022.3.15f1 (bce4550a1dad)
`;

const PACKAGE_MANIFEST = JSON.stringify(
  {
    dependencies: {
      "com.unity.collab-proxy": "1.17.7",
      "com.unity.ide.rider": "3.0.21",
      "com.unity.ide.visualstudio": "2.0.22",
      "com.unity.ide.vscode": "1.2.5",
      "com.unity.test-framework": "1.1.33",
      "com.unity.textmeshpro": "3.0.6",
      "com.unity.timeline": "1.7.4",
      "com.unity.ugui": "1.0.0",
      "com.unity.modules.ai": "1.0.0",
      "com.unity.modules.animation": "1.0.0",
      "com.unity.modules.audio": "1.0.0",
      "com.unity.modules.imgui": "1.0.0",
      "com.unity.modules.physics": "1.0.0",
      "com.unity.modules.physics2d": "1.0.0",
      "com.unity.modules.tilemap": "1.0.0",
      "com.unity.modules.ui": "1.0.0",
      "com.unity.modules.unitywebrequest": "1.0.0"
    }
  },
  null,
  2
);

function sanitizeFolderName(name, fallback) {
  const normalized =
    (name ?? "")
      .toString()
      .trim()
      .replace(/[^A-Za-z0-9-_]+/g, "-") || fallback;
  return normalized.length ? normalized : fallback;
}

function sanitizeIdentifier(name, fallback) {
  const normalized =
    (name ?? "")
      .toString()
      .trim()
      .replace(/[^A-Za-z0-9_]+/g, "") || fallback;
  return normalized.length ? normalized : fallback;
}

async function createUnityTemplate(projectRoot, options) {
  const {
    projectName,
    sceneName,
    scriptName,
    scriptContents,
    sceneContents
  } = options;

  const assetsDir = path.join(projectRoot, "Assets");
  const scriptsDir = path.join(assetsDir, "Scripts");
  const scenesDir = path.join(assetsDir, "Scenes");
  const packagesDir = path.join(projectRoot, "Packages");
  const settingsDir = path.join(projectRoot, "ProjectSettings");

  await Promise.all([
    mkdir(scriptsDir, { recursive: true }),
    mkdir(scenesDir, { recursive: true }),
    mkdir(packagesDir, { recursive: true }),
    mkdir(settingsDir, { recursive: true })
  ]);

  const scriptFile = path.join(scriptsDir, `${scriptName}.cs`);
  const sceneFile = path.join(scenesDir, `${sceneName}.unity`);
  const packageManifest = path.join(packagesDir, "manifest.json");
  const projectVersion = path.join(settingsDir, "ProjectVersion.txt");
  const projectReadme = path.join(projectRoot, "README.md");

  await Promise.all([
    writeFile(
      scriptFile,
      scriptContents ?? createDefaultScript(scriptName),
      "utf8"
    ),
    writeFile(sceneFile, sceneContents ?? DEFAULT_SCENE, "utf8"),
    writeFile(packageManifest, PACKAGE_MANIFEST, "utf8"),
    writeFile(projectVersion, PROJECT_VERSION, "utf8"),
    writeFile(
      projectReadme,
      `# ${projectName}\n\nGenerated by the BlackRoad Unity exporter.\n`,
      "utf8"
    )
  ]);
}

app.post("/export", async (req, res) => {
  const body = req.body ?? {};

  const projectName = sanitizeFolderName(
    body.projectName,
    DEFAULT_PROJECT_NAME
  );
  const sceneName = sanitizeFolderName(body.sceneName, DEFAULT_SCENE_NAME);
  const scriptName = sanitizeIdentifier(
    body.scriptName,
    DEFAULT_SCRIPT_NAME
  );

  const outDir = path.join(process.cwd(), "downloads");
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
  const archiveName = `${projectName}-${timestamp}.zip`;
  const zipPath = path.join(outDir, archiveName);

  let tempRoot;
  try {
    await mkdir(outDir, { recursive: true });

    tempRoot = await mkdtemp(path.join(os.tmpdir(), "unity-exporter-"));
    const projectRoot = path.join(tempRoot, projectName);
    await mkdir(projectRoot, { recursive: true });

    await createUnityTemplate(projectRoot, {
      projectName,
      sceneName,
      scriptName,
      scriptContents: body.scriptContents,
      sceneContents: body.sceneContents
    });

    await rm(zipPath, { force: true });
    await execFileAsync("zip", ["-r", zipPath, projectName], {
      cwd: tempRoot
const archiveTemplate = async ({ files, slug }) => {
  const outDir = path.join(process.cwd(), "downloads");
  await mkdir(outDir, { recursive: true });
  const fileName = `${slug}-${Date.now()}-${crypto
    .randomBytes(3)
    .toString("hex")}.zip`;
  const zipPath = path.join(outDir, fileName);

  await new Promise((resolve, reject) => {
    const output = createWriteStream(zipPath);
    const archive = archiver("zip", { zlib: { level: 9 } });

    output.on("close", resolve);
    output.on("error", reject);
    archive.on("error", reject);

    archive.pipe(output);
    files.forEach((file) => {
      archive.append(file.content, { name: file.path });
    });
    archive.finalize();
  });

  return { zipPath, fileName };
};

app.post("/export", async (req, res) => {
  try {
    const template = buildUnityTemplate(req.body ?? {});
    const { zipPath, fileName } = await archiveTemplate({
      files: template.files,
      slug: template.slug,
app.use(express.json({ limit: "1mb" }));

const DEFAULT_SCENES = [
  {
    name: "SampleScene",
    description: "Starter layout with a rotating cube and directional light.",
    camera: {
      position: { x: 0, y: 1.2, z: -4 },
      rotation: { x: 10, y: 0, z: 0 },
    },
    rotationSpeed: 30,
  },
];

const sanitizeForPath = (value, fallback) => {
  if (typeof value !== "string") {
    return fallback;
  }
  const trimmed = value.trim();
  if (!trimmed) {
    return fallback;
  }
  const sanitized = trimmed.replace(/[^A-Za-z0-9_-]+/g, "_");
  return sanitized || fallback;
};

const makeGuid = () => crypto.randomUUID().replace(/-/g, "").toLowerCase();

const DEG2RAD = Math.PI / 180;
const eulerToQuaternion = ({ x = 0, y = 0, z = 0 }) => {
  const halfX = (x * DEG2RAD) / 2;
  const halfY = (y * DEG2RAD) / 2;
  const halfZ = (z * DEG2RAD) / 2;

  const sinX = Math.sin(halfX);
  const cosX = Math.cos(halfX);
  const sinY = Math.sin(halfY);
  const cosY = Math.cos(halfY);
  const sinZ = Math.sin(halfZ);
  const cosZ = Math.cos(halfZ);

  const quaternion = {
    x: sinX * cosY * cosZ + cosX * sinY * sinZ,
    y: cosX * sinY * cosZ - sinX * cosY * sinZ,
    z: cosX * cosY * sinZ + sinX * sinY * cosZ,
    w: cosX * cosY * cosZ - sinX * sinY * sinZ,
  };

  const magnitude = Math.hypot(quaternion.x, quaternion.y, quaternion.z, quaternion.w) || 1;

  return {
    x: quaternion.x / magnitude,
    y: quaternion.y / magnitude,
    z: quaternion.z / magnitude,
    w: quaternion.w / magnitude,
  };
};

const ensureScenes = (scenes) => {
  const candidates = Array.isArray(scenes) ? scenes : [];
  const normalized = candidates
    .map((scene, index) => {
      if (!scene || typeof scene !== "object") {
        return null;
      }
      const rawName =
        typeof scene.name === "string" && scene.name.trim()
          ? scene.name.trim()
          : `Scene${index + 1}`;
      const fileName = `${sanitizeForPath(rawName, `Scene${index + 1}`)}.unity`;
      const guid =
        typeof scene.guid === "string" && /^[a-f0-9]{32}$/i.test(scene.guid)
          ? scene.guid.toLowerCase()
          : makeGuid();
      return {
        name: rawName,
        fileName,
        guid,
        description:
          typeof scene.description === "string" && scene.description.trim()
            ? scene.description.trim()
            : "Generated scene stub created by the BlackRoad Unity exporter.",
        camera: {
          position: {
            x: Number(scene?.camera?.position?.x ?? 0),
            y: Number(scene?.camera?.position?.y ?? 1),
            z: Number(scene?.camera?.position?.z ?? -10),
          },
          rotation: {
            x: Number(scene?.camera?.rotation?.x ?? 0),
            y: Number(scene?.camera?.rotation?.y ?? 0),
            z: Number(scene?.camera?.rotation?.z ?? 0),
          },
        },
        rotationSpeed: Number.isFinite(scene?.rotationSpeed)
          ? Number(scene.rotationSpeed)
          : 45,
      };
    })
    .filter(Boolean);

  if (normalized.length > 0) {
    return normalized;
  }

  return DEFAULT_SCENES.map((scene, index) => ({
    ...scene,
    fileName: `${sanitizeForPath(scene.name, `Scene${index + 1}`)}.unity`,
    guid: makeGuid(),
  }));
};

const renderSceneUnity = (scene, bootstrapGuid) => {
  const { position, rotation } = scene.camera;
  const quaternion = eulerToQuaternion(rotation);
  return `// ${scene.name}.unity\n// ${scene.description}\n%YAML 1.1\n%TAG !u! tag:unity3d.com,2011:\n--- !u!1 &1000\nGameObject:\n  m_ObjectHideFlags: 0\n  m_Name: Main Camera\n  m_Component:\n  - component: {fileID: 1001}\n  - component: {fileID: 1002}\n  - component: {fileID: 1003}\n  m_Transform: {fileID: 1004}\n--- !u!20 &1001\nCamera:\n  m_ObjectHideFlags: 0\n  m_GameObject: {fileID: 1000}\n  field of view: 60\n  m_FocalLength: 50\n  near clip plane: 0.3\n  far clip plane: 1000\n--- !u!81 &1002\nAudioListener:\n  m_ObjectHideFlags: 0\n  m_GameObject: {fileID: 1000}\n--- !u!92 &1003\nBehaviour:\n  m_ObjectHideFlags: 0\n  m_GameObject: {fileID: 1000}\n--- !u!4 &1004\nTransform:\n  m_ObjectHideFlags: 0\n  m_GameObject: {fileID: 1000}\n  m_LocalPosition: {x: ${position.x.toFixed(2)}, y: ${position.y.toFixed(2)}, z: ${position.z.toFixed(2)}}\n  m_LocalRotation: {x: ${quaternion.x.toFixed(6)}, y: ${quaternion.y.toFixed(6)}, z: ${quaternion.z.toFixed(6)}, w: ${quaternion.w.toFixed(6)}}\n  m_LocalScale: {x: 1, y: 1, z: 1}\n--- !u!1 &2000\nGameObject:\n  m_ObjectHideFlags: 0\n  m_Name: Scene Bootstrap\n  m_Component:\n  - component: {fileID: 2001}\n  m_Transform: {fileID: 2002}\n--- !u!4 &2002\nTransform:\n  m_ObjectHideFlags: 0\n  m_GameObject: {fileID: 2000}\n  m_LocalPosition: {x: 0, y: 0, z: 0}\n  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}\n  m_LocalScale: {x: 1, y: 1, z: 1}\n--- !u!114 &2001\nMonoBehaviour:\n  m_ObjectHideFlags: 0\n  m_GameObject: {fileID: 2000}\n  m_Script: {fileID: 11500000, guid: ${bootstrapGuid}, type: 3}\n  m_Name: SceneBootstrap\n  m_EditorClassIdentifier: \n  sceneLabel: ${scene.name}\n  sceneDescription: ${scene.description}\n  rotationSpeed: ${scene.rotationSpeed}\n`;
};

const renderSceneMeta = (guid) => `fileFormatVersion: 2\nguid: ${guid}\nSceneImporter:\n  externalObjects: {}\n  userData: \n  assetBundleName: \n  assetBundleVariant: \n`;

const renderBootstrapScript = () => `using UnityEngine;\n\npublic class Bootstrap : MonoBehaviour\n{\n    [SerializeField]\n    private string sceneLabel = \"Generated Scene\";\n\n    [SerializeField, TextArea(2, 6)]\n    private string sceneDescription = \"\";\n\n    [SerializeField]\n    private float rotationSpeed = 45f;\n\n    private GameObject demoCube;\n\n    private void Start()\n    {\n        Debug.Log($\"[BlackRoad] Loaded scene '{sceneLabel}' - {sceneDescription}\");\n\n        demoCube = GameObject.CreatePrimitive(PrimitiveType.Cube);\n        demoCube.name = \"BlackRoadDemoCube\";\n        demoCube.transform.position = new Vector3(0f, 0.5f, 0f);\n        var material = new Material(Shader.Find(\"Universal Render Pipeline/Lit\"));\n        material.color = new Color(0.2f, 0.6f, 0.9f);\n        var renderer = demoCube.GetComponent<Renderer>();\n        if (renderer != null)\n        {\n            renderer.material = material;\n        }\n    }\n\n    private void Update()\n    {\n        if (demoCube == null)\n        {\n            return;\n        }\n\n        demoCube.transform.Rotate(Vector3.up, rotationSpeed * Time.deltaTime, Space.World);\n    }\n}\n`;

const renderBootstrapMeta = (guid) => `fileFormatVersion: 2\nguid: ${guid}\nMonoImporter:\n  externalObjects: {}\n  serializedVersion: 2\n  defaultReferences: []\n  executionOrder: 0\n  icon: {instanceID: 0}\n  userData: \n  assetBundleName: \n  assetBundleVariant: \n`;

const renderPackagesManifest = () =>
  `${JSON.stringify(
    {
      dependencies: {
        "com.unity.collab-proxy": "2.0.5",
        "com.unity.ide.visualstudio": "2.0.22",
        "com.unity.ide.vscode": "1.2.5",
        "com.unity.render-pipelines.universal": "14.0.8",
        "com.unity.test-framework": "1.3.6",
        "com.unity.textmeshpro": "3.0.6",
        "com.unity.timeline": "1.7.6",
        "com.unity.ugui": "1.0.0",
        "com.unity.modules.ai": "1.0.0",
        "com.unity.modules.animation": "1.0.0",
        "com.unity.modules.audio": "1.0.0",
        "com.unity.modules.physics": "1.0.0",
        "com.unity.modules.physics2d": "1.0.0",
        "com.unity.modules.particlesystem": "1.0.0",
        "com.unity.modules.ui": "1.0.0",
        "com.unity.modules.unitywebrequest": "1.0.0",
      },
    },
    null,
    2
  )}\n`;

const renderEditorBuildSettings = (scenes) => {
  const sceneLines = scenes
    .map(
      (scene) =>
        `  - enabled: 1\n    path: Assets/Scenes/${scene.fileName}\n    guid: ${scene.guid}`
    )
    .join("\n");

  return `%YAML 1.1\n%TAG !u! tag:unity3d.com,2011:\n--- !u!1045 &1\nEditorBuildSettings:\n  m_ObjectHideFlags: 0\n  serializedVersion: 2\n  m_Scenes:\n${sceneLines}\n  m_configObjects: {}\n`;
};

const renderProjectVersion = () => `m_EditorVersion: 2022.3.21f1\nm_EditorVersionWithRevision: 2022.3.21f1 (b1234567890ab)\n`;

const renderReadme = (projectName, description, scenes, generatedAt) => {
  const sceneList = scenes
    .map((scene) => `- ${scene.name} → Assets/Scenes/${scene.fileName}`)
    .join("\n");

  return `# ${projectName}\n\n${description || "Unity project exported via the BlackRoad pipeline."}\n\n## Scenes\n${sceneList}\n\nGenerated at ${generatedAt}.\n`;
};

app.post("/export", async (req, res) => {
  const { projectName = "BlackRoadUnityPrototype", description = "", scenes } = req.body ?? {};
  const normalizedScenes = ensureScenes(scenes);
  const generatedAt = new Date().toISOString();
  const outDir = path.join(process.cwd(), "downloads");
  const safeFolderName = sanitizeForPath(projectName, "BlackRoadUnityProject");
  const timestamp = generatedAt.replace(/[:.]/g, "-");
  const zipFileName = `${safeFolderName}-${timestamp}.zip`;
  const zipPath = path.join(outDir, zipFileName);
  const bootstrapGuid = makeGuid();

  try {
    await mkdir(outDir, { recursive: true });
    const archive = archiver("zip", { zlib: { level: 9 } });
    const output = createWriteStream(zipPath);
    archive.pipe(output);

    const projectMetadata = {
      name: projectName,
      description,
      generatedAt,
      scenes: normalizedScenes,
    };

    archive.append(renderPackagesManifest(), {
      name: `${safeFolderName}/Packages/manifest.json`,
    });
    archive.append(renderProjectVersion(), {
      name: `${safeFolderName}/ProjectSettings/ProjectVersion.txt`,
    });
    archive.append(renderEditorBuildSettings(normalizedScenes), {
      name: `${safeFolderName}/ProjectSettings/EditorBuildSettings.asset`,
    });

    const bootstrapScriptPath = `${safeFolderName}/Assets/Scripts/Bootstrap.cs`;
    archive.append(renderBootstrapScript(), { name: bootstrapScriptPath });
    archive.append(renderBootstrapMeta(bootstrapGuid), {
      name: `${bootstrapScriptPath}.meta`,
    });

    normalizedScenes.forEach((scene) => {
      archive.append(renderSceneUnity(scene, bootstrapGuid), {
        name: `${safeFolderName}/Assets/Scenes/${scene.fileName}`,
      });
      archive.append(renderSceneMeta(scene.guid), {
        name: `${safeFolderName}/Assets/Scenes/${scene.fileName}.meta`,
      });
    });

    archive.append(JSON.stringify(projectMetadata, null, 2) + "\n", {
      name: `${safeFolderName}/blackroad_export.json`,
    });
    archive.append(renderReadme(projectName, description, normalizedScenes, generatedAt), {
      name: `${safeFolderName}/README.md`,
    });

    await new Promise((resolve, reject) => {
      output.on("close", resolve);
      output.on("error", reject);
      archive.on("error", reject);
      archive.finalize();
    });
const DEFAULT_PROJECT_NAME = "BlackRoadUnity";
const DEFAULT_DESCRIPTION =
  "Starter Unity project generated by the BlackRoad exporter.";
const DEFAULT_SCENES = ["SampleScene"];
const UNITY_VERSION = "2022.3.36f1";
const UNITY_VERSION_WITH_REVISION = `${UNITY_VERSION} (000000000000)`;

const sanitizeProjectName = (name) => {
  if (typeof name !== "string") return DEFAULT_PROJECT_NAME;
  const trimmed = name.trim();
  if (!trimmed) return DEFAULT_PROJECT_NAME;
  const normalized = trimmed
    .replace(/[^A-Za-z0-9-_\s]/g, "-")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "");
  return normalized ? normalized.slice(0, 64) : DEFAULT_PROJECT_NAME;
};

const sanitizeSceneName = (name) => {
  if (typeof name !== "string") return null;
  const trimmed = name.trim();
  if (!trimmed) return null;
  const normalized = trimmed
    .replace(/[^A-Za-z0-9-_\s]/g, "-")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^-|-$/g, "");
  return normalized || null;
};

const normalizeScenes = (scenes) => {
  if (scenes === undefined) return DEFAULT_SCENES;
  if (!Array.isArray(scenes)) return null;
  const deduped = new Set();
  for (const entry of scenes) {
    let candidate = entry;
    if (entry && typeof entry === "object" && typeof entry.name === "string") {
      candidate = entry.name;
    }
    const sanitized = sanitizeSceneName(candidate);
    if (sanitized) {
      deduped.add(sanitized);
    }
  }
  return deduped.size > 0 ? Array.from(deduped) : DEFAULT_SCENES;
};

const projectReadme = (projectName, description, scenes) => {
  const sceneList = scenes.map((scene) => `- Assets/Scenes/${scene}.unity`).join("\n");
  return `# ${projectName}\n\n${description}\n\n## Included Scenes\n${sceneList}\n\nGenerated on ${new Date().toISOString()} by the Unity exporter service.`;
};

const manifestJson = `{
  "dependencies": {
    "com.unity.collab-proxy": "2.0.5",
    "com.unity.ide.rider": "3.0.24",
    "com.unity.ide.visualstudio": "2.0.22",
    "com.unity.test-framework": "1.3.9",
    "com.unity.textmeshpro": "3.0.6",
    "com.unity.timeline": "1.7.5",
    "com.unity.ugui": "1.0.0",
    "com.unity.visualscripting": "1.9.4"
  }
}`;

const projectVersionFile = () =>
  `m_EditorVersion: ${UNITY_VERSION}\nm_EditorVersionWithRevision: ${UNITY_VERSION_WITH_REVISION}\n`; // newline at end of file expected by Unity

const editorBuildSettings = (scenes) => {
  const sceneEntries = scenes
    .map(
      (scene) => `  - enabled: 1\n    path: Assets/Scenes/${scene}.unity\n    guid: ${randomUUID().replace(/-/g, "")}`,
    )
    .join("\n");
  return `%YAML 1.1\n%TAG !u! tag:unity3d.com,2011:\n--- !u!1045 &1\nEditorBuildSettings:\n  m_ObjectHideFlags: 0\n  serializedVersion: 2\n  m_Scenes:\n${sceneEntries}\n  m_configObjects: {}\n`;
};

const defaultSceneContent = (scene) => `// ${scene}.unity\n// Placeholder scene generated by the BlackRoad Unity exporter.\n// Open this project in Unity to replace it with a real scene.\n`;

app.post("/export", async (req, res) => {
  const {
    projectName: requestedProjectName,
    description = DEFAULT_DESCRIPTION,
    scenes: requestedScenes,
  } = req.body ?? {};

  const projectName = sanitizeProjectName(requestedProjectName);
  const scenes = normalizeScenes(requestedScenes);

  if (!scenes) {
    res
      .status(400)
      .json({ ok: false, error: "`scenes` must be an array of names or { name } objects." });
    return;
  }

  let stagingRoot;
  try {
    const downloadsDir = path.join(process.cwd(), "downloads");
    await mkdir(downloadsDir, { recursive: true });

    stagingRoot = await mkdtemp(path.join(tmpdir(), "unity-export-"));
    const projectRoot = path.join(stagingRoot, projectName);
    await mkdir(projectRoot, { recursive: true });

    const createdFiles = [];
    const writeRelativeFile = async (relativePath, contents) => {
      const targetPath = path.join(projectRoot, relativePath);
      await mkdir(path.dirname(targetPath), { recursive: true });
      await writeFile(targetPath, contents, "utf8");
      createdFiles.push(relativePath.replace(/\\/g, "/"));
    };

    await writeRelativeFile("README.md", projectReadme(projectName, description, scenes));
    await writeRelativeFile("Packages/manifest.json", `${manifestJson}\n`);
    await writeRelativeFile("ProjectSettings/ProjectVersion.txt", projectVersionFile());
    await writeRelativeFile(
      "ProjectSettings/EditorBuildSettings.asset",
      editorBuildSettings(scenes),
    );
    await writeRelativeFile(
      "Assets/Scripts/README.md",
      `# Scripts\n\nAdd your gameplay scripts in this folder.\n\nGenerated scenes:\n${scenes
        .map((scene) => `- ${scene}`)
        .join("\n")}\n`,
    );

    for (const scene of scenes) {
      await writeRelativeFile(`Assets/Scenes/${scene}.unity`, defaultSceneContent(scene));
    }

    const zipTempDir = stagingRoot;
    const zipTempPath = path.join(zipTempDir, `${projectName}.zip`);
    const zipTargetPath = path.join(
      downloadsDir,
      `${projectName}-${Date.now().toString(36)}.zip`,
    );

    try {
      await execFileAsync("zip", ["-r", zipTempPath, projectName], {
        cwd: zipTempDir,
      });
    } catch (error) {
      const stderr = error?.stderr?.toString() ?? "";
      throw new Error(`Failed to create zip archive: ${error.message || error}. ${stderr}`);
    }

    await rename(zipTempPath, zipTargetPath);

    res.json({
      ok: true,
      projectName,
      sceneName,
      scriptName,
      path: zipPath
    });
  } catch (error) {
    console.error("unity exporter error", error);
    res.status(500).json({ ok: false, error: String(error) });
  } finally {
    if (tempRoot) {
      try {
        await rm(tempRoot, { recursive: true, force: true });
      } catch (cleanupError) {
        console.warn("failed to clean up temp directory", cleanupError);
      }
    }
      output: zipPath,
      fileName,
      projectName: template.projectName,
      sceneName: template.sceneName,
      files: template.files.map((file) => file.path),
    });
  } catch (error) {
    console.error("Failed to export Unity project", error);
      path: zipPath,
      fileName: zipFileName,
      project: projectMetadata,
    });
  } catch (error) {
    console.error("Unity exporter failed", error);
    res.status(500).json({ ok: false, error: String(error) });
  writeFile,
  rm,
  stat
} from "fs/promises";
import os from "os";
import path from "path";
import { promisify } from "util";

const execFileAsync = promisify(execFile);

class ExportError extends Error {
  constructor(message, status = 500) {
    super(message);
    this.status = status;
  }
}

const app = express();
app.use(express.json({ limit: "1mb" }));

app.post("/export", async (req, res) => {
  try {
    const { projectName, scenes, description } = req.body ?? {};
    const safeProjectName = sanitizeProjectName(projectName);
    const safeScenes = normalizeScenes(scenes);
    const exportInfo = await createUnityProject({
      projectName: safeProjectName,
      scenes: safeScenes,
      description: typeof description === "string" ? description.trim() : undefined
    });
    res.json({
      ok: true,
      ...exportInfo
    });
  } catch (error) {
    const status = error instanceof ExportError ? error.status : 500;
    const message = error instanceof Error ? error.message : "Unknown error";
    console.error("Unity export failed", error);
    res.status(status).json({ ok: false, error: message });
import path from "path";
import { mkdir } from "fs/promises";

import {
  buildProjectSpec,
  exportUnityProject,
} from "./projectGenerator.js";

const app = express();
app.use(express.json({ limit: "1mb" }));

app.post("/export", async (req, res) => {
  try {
    const spec = buildProjectSpec(req.body ?? {});
    const outDir = path.join(process.cwd(), "downloads");
    await mkdir(outDir, { recursive: true });

    const filename = `${spec.slug}-${Date.now()}.zip`;
    const zipPath = path.join(outDir, filename);
    await exportUnityProject(spec, zipPath);

    res.json({
      ok: true,
      projectName: spec.projectName,
      sceneName: spec.sceneName,
      objects: spec.objects.length,
      path: zipPath,
    });
  } catch (error) {
    const status = error?.statusCode ?? 500;
    res.status(status).json({
      ok: false,
      error: error?.message ?? String(error),
    });
      path: zipTargetPath,
      files: createdFiles.sort(),
    });
  } catch (error) {
    console.error("Unity export failed", error);
    res.status(500).json({ ok: false, error: error?.message || String(error) });
  } finally {
    if (stagingRoot) {
      try {
        await rm(stagingRoot, { recursive: true, force: true });
      } catch (cleanupError) {
        console.warn("Failed to clean up staging directory", cleanupError);
      }
    }
  }
});

const port = process.env.PORT || 3000;
app.listen(port, () => console.log("unity exporter listening on", port));

function sanitizeProjectName(name) {
  if (typeof name !== "string") {
    return "BlackRoadUnityProject";
  }
  const cleaned = name
    .trim()
    .replace(/[^A-Za-z0-9 _-]/g, "")
    .replace(/\s+/g, "-")
    .replace(/-+/g, "-")
    .replace(/^[-_]+|[-_]+$/g, "");
  return cleaned ? cleaned.slice(0, 64) : "BlackRoadUnityProject";
}

function normalizeScenes(input) {
  if (input === undefined) {
    return ["MainScene"];
  }
  if (!Array.isArray(input)) {
    throw new ExportError("`scenes` must be an array of names", 400);
  }
  const sanitized = input
    .map((scene) => (typeof scene === "string" ? scene : ""))
    .map((scene) =>
      scene
        .trim()
        .replace(/[^A-Za-z0-9 _-]/g, "")
        .replace(/\s+/g, "_")
        .replace(/_+/g, "_")
        .replace(/^[_-]+|[_-]+$/g, "")
    )
    .filter(Boolean);
  const uniqueScenes = Array.from(new Set(sanitized)).slice(0, 20);
  return uniqueScenes.length > 0 ? uniqueScenes : ["MainScene"];
}

async function createUnityProject({ projectName, scenes, description }) {
  const tempRoot = await mkdtemp(path.join(os.tmpdir(), "unity-export-"));
  const projectRoot = path.join(tempRoot, projectName);
  const scenesDir = path.join(projectRoot, "Assets", "Scenes");
  const projectSettingsDir = path.join(projectRoot, "ProjectSettings");
  const packagesDir = path.join(projectRoot, "Packages");

  try {
    await mkdir(scenesDir, { recursive: true });
    await mkdir(projectSettingsDir, { recursive: true });
    await mkdir(packagesDir, { recursive: true });

    await Promise.all([
      writeReadme(projectRoot, projectName, description),
      writeBuildSettings(projectSettingsDir, scenes),
      writeProjectVersion(projectSettingsDir),
      writeProjectSettings(projectSettingsDir),
      writeManifest(packagesDir)
    ]);

    await Promise.all(
      scenes.map((sceneName, index) =>
        writeScene(path.join(scenesDir, `${sceneName}.unity`), sceneName, index)
      )
    );

    const downloadsDir = path.join(process.cwd(), "downloads");
    await mkdir(downloadsDir, { recursive: true });
    const zipPath = path.join(
      downloadsDir,
      `${projectName}-${Date.now()}.zip`
    );

    try {
      await execFileAsync("zip", ["-rq", zipPath, projectName], {
        cwd: tempRoot
      });
    } catch (error) {
      throw new ExportError(
        "Failed to bundle Unity project. Ensure the `zip` utility is available.",
        500
      );
    }

    const fileStats = await stat(zipPath);
    return {
      path: zipPath,
      projectName,
      scenes,
      size: fileStats.size,
      createdAt: new Date().toISOString()
    };
  } finally {
    await rm(tempRoot, { recursive: true, force: true });
  }
}

async function writeReadme(projectRoot, projectName, description) {
  const contents = [`# ${projectName}`, "", description?.trim() || "Unity project scaffold generated by BlackRoad.", "", "## Getting Started", "1. Open the project in Unity 2022.3 LTS or newer.", "2. Review the generated scenes under `Assets/Scenes`.", "3. Update project settings and packages to match your team's standards."].join("\n");
  await writeFile(path.join(projectRoot, "README.md"), contents, "utf8");
}

async function writeBuildSettings(projectSettingsDir, scenes) {
  const entries = scenes
    .map(
      (scene) =>
        "  - enabled: 1\n" +
        `    path: Assets/Scenes/${scene}.unity\n` +
        "    guid: 00000000000000000000000000000000"
    )
    .join("\n");
  const contents =
    "%YAML 1.1\n" +
    "%TAG !u! tag:unity3d.com,2011:\n" +
    "--- !u!1045 &1\n" +
    "EditorBuildSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "  serializedVersion: 2\n" +
    "  m_Scenes:\n" +
    entries +
    "\n  m_configObjects: {}\n";
  await writeFile(
    path.join(projectSettingsDir, "EditorBuildSettings.asset"),
    contents,
    "utf8"
  );
}

async function writeProjectVersion(projectSettingsDir) {
  const contents = [
    "m_EditorVersion: 2022.3.21f1",
    "m_EditorVersionWithRevision: 2022.3.21f1 (revision 6c5b472a2d91)"
  ].join("\n");
  await writeFile(
    path.join(projectSettingsDir, "ProjectVersion.txt"),
    contents,
    "utf8"
  );
}

async function writeProjectSettings(projectSettingsDir) {
  const contents =
    "%YAML 1.1\n" +
    "%TAG !u! tag:unity3d.com,2011:\n" +
    "--- !u!129 &1\n" +
    "PlayerSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "  serializedVersion: 23\n" +
    "  productName: BlackRoad Prototype\n" +
    "  companyName: BlackRoad Labs\n" +
    "  defaultScreenWidth: 1920\n" +
    "  defaultScreenHeight: 1080\n" +
    "  fullscreenMode: 1\n" +
    "  defaultScreenOrientation: 4\n" +
    "  displayResolutionDialog: 1\n" +
    "  targetDevice: 2\n" +
    "  usePlayerLog: 1\n" +
    "  forceSingleInstance: 0\n" +
    "  resizableWindow: 1\n" +
    "  useMacAppStoreValidation: 0\n" +
    "  protectGraphicsMemory: 0\n" +
    "  visibleInBackground: 1\n" +
    "  allowFullscreenSwitch: 1\n" +
    "  runInBackground: 1\n" +
    "  captureSingleScreen: 0\n";
  await writeFile(
    path.join(projectSettingsDir, "ProjectSettings.asset"),
    contents,
    "utf8"
  );
}

async function writeManifest(packagesDir) {
  const manifest = {
    dependencies: {
      "com.unity.collab-proxy": "1.17.7",
      "com.unity.ide.rider": "3.0.24",
      "com.unity.ide.visualstudio": "2.0.22",
      "com.unity.ide.vscode": "1.2.5",
      "com.unity.render-pipelines.universal": "14.0.10",
      "com.unity.test-framework": "1.3.9",
      "com.unity.textmeshpro": "3.0.6",
      "com.unity.timeline": "1.7.5",
      "com.unity.ugui": "1.0.0",
      "com.unity.modules.ai": "1.0.0",
      "com.unity.modules.animation": "1.0.0",
      "com.unity.modules.audio": "1.0.0",
      "com.unity.modules.director": "1.0.0",
      "com.unity.modules.imageconversion": "1.0.0",
      "com.unity.modules.jsonserialize": "1.0.0",
      "com.unity.modules.particlesystem": "1.0.0",
      "com.unity.modules.physics": "1.0.0",
      "com.unity.modules.physics2d": "1.0.0",
      "com.unity.modules.tilemap": "1.0.0",
      "com.unity.modules.ui": "1.0.0",
      "com.unity.modules.uielements": "1.0.0",
      "com.unity.modules.unitywebrequest": "1.0.0",
      "com.unity.modules.video": "1.0.0"
    }
  };
  await writeFile(
    path.join(packagesDir, "manifest.json"),
    JSON.stringify(manifest, null, 2),
    "utf8"
  );
}

async function writeScene(scenePath, sceneName, index) {
  const contents =
    "%YAML 1.1\n" +
    "%TAG !u! tag:unity3d.com,2011:\n" +
    "--- !u!29 &1\n" +
    "SceneSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "--- !u!104 &2\n" +
    "RenderSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "--- !u!157 &3\n" +
    "LightmapSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "--- !u!196 &4\n" +
    "NavMeshSettings:\n" +
    "  m_ObjectHideFlags: 0\n" +
    "--- !u!1 &1000\n" +
    "GameObject:\n" +
    `  m_Name: ${sceneName}\n` +
    "  m_Component:\n" +
    "  - component: {fileID: 2000}\n" +
    "  m_Layer: 0\n" +
    "  m_IsActive: 1\n" +
    "--- !u!4 &2000\n" +
    "Transform:\n" +
    "  m_GameObject: {fileID: 1000}\n" +
    "  m_LocalPosition: {x: 0, y: 0, z: 0}\n" +
    "  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}\n" +
    "  m_LocalScale: {x: 1, y: 1, z: 1}\n" +
    `  m_RootOrder: ${index}\n` +
    "  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}\n";
  await writeFile(scenePath, contents, "utf8");
}
app.listen(port, () => {
  console.log("unity exporter listening on", port);
});

export default app;
