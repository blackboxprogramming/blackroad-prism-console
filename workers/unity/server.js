import express from "express";
import { mkdir, writeFile } from "fs/promises";
import path from "path";
import JSZip from "jszip";

const app = express();
app.use(express.json({ limit: "1mb" }));

const DEFAULT_PROJECT_NAME = "BlackRoadUnityProject";
const DEFAULT_VERSION = "2022.3.10f1";
const DEFAULT_PIPELINE = "builtin";
const DEFAULT_TEMPLATE = "core";

const PIPELINE_PACKAGES = {
  builtin: {
    dependencies: {},
    summary: "Unity Built-in Render Pipeline",
  },
  urp: {
    dependencies: {
      "com.unity.render-pipelines.universal": "14.0.11",
    },
    summary: "Universal Render Pipeline tuned for cross-platform builds",
  },
  hdrp: {
    dependencies: {
      "com.unity.render-pipelines.high-definition": "14.0.11",
    },
    summary: "High Definition Render Pipeline for cinematic visuals",
  },
};

const BASE_DEPENDENCIES = {
  "com.unity.collab-proxy": "2.0.5",
  "com.unity.ide.visualstudio": "2.0.22",
  "com.unity.ide.vscode": "1.2.5",
  "com.unity.timeline": "1.7.5",
  "com.unity.cinemachine": "2.9.7",
};

function sanitizeProjectName(projectName) {
  if (typeof projectName !== "string" || projectName.trim() === "") {
    return DEFAULT_PROJECT_NAME;
  }
  return projectName.trim().replace(/[^a-zA-Z0-9_-]+/g, "-");
}

function coerceVersions(unityVersions) {
  if (Array.isArray(unityVersions) && unityVersions.length > 0) {
    return unityVersions
      .map((version) => (typeof version === "string" ? version.trim() : ""))
      .filter((version) => version.length > 0);
  }
  if (typeof unityVersions === "string" && unityVersions.trim() !== "") {
    return [unityVersions.trim()];
  }
  return [DEFAULT_VERSION];
}

function normalizePipeline(pipeline) {
  const requested = typeof pipeline === "string" ? pipeline.toLowerCase() : "";
  if (requested in PIPELINE_PACKAGES) {
    return requested;
  }
  return DEFAULT_PIPELINE;
}

function manifestForPipeline(pipeline) {
  const selected = PIPELINE_PACKAGES[pipeline] ?? PIPELINE_PACKAGES[DEFAULT_PIPELINE];
  const deps = { ...BASE_DEPENDENCIES, ...selected.dependencies };
  return `${JSON.stringify(
    {
      dependencies: deps,
    },
    null,
    2,
  )}
`;
}

function projectVersionFile(version) {
  return `m_EditorVersion: ${version}
m_EditorVersionWithRevision: ${version} (blackroad-unity-exporter)
`;
}

function projectSettingsAsset(projectName, pipeline) {
  return `%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!129 &1
PlayerSettings:
  m_ObjectHideFlags: 0
  serializedVersion: 23
  productName: ${projectName}
  companyName: BlackRoad
  organizationId: blackroad
  defaultScreenWidth: 1920
  defaultScreenHeight: 1080
  runInBackground: 1
  visibleInBackground: 1
  bundleVersion: 0.1.0
  activeColorSpace: 1
  renderingPath: ${pipeline === "hdrp" ? 3 : pipeline === "urp" ? 2 : 1}
  scriptingBackend: 1
  additionalCompilerArguments: -define:BLACKROAD_EXPORT
  unitySplashScreen: 0
  renderPipelineAsset: ${pipeline.toUpperCase()}_PIPELINE_PLACEHOLDER
`;
}

function placeholderScene({ projectName, pipeline, template }) {
  return `%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &1
GameObject:
  m_ObjectHideFlags: 0
  m_Name: ${projectName}Root
  m_Component:
  - component: {fileID: 4}
  m_Children: []
  m_Layer: 0
  m_IsActive: 1
--- !u!4 &4
Transform:
  m_ObjectHideFlags: 0
  m_GameObject: {fileID: 1}
  m_LocalPosition: {x: 0, y: 0, z: 0}
  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}
  m_LocalScale: {x: 1, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 0}
  m_RootOrder: 0
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
# Pipeline: ${pipeline}
# Template: ${template}
# Scene placeholder for BlackRoad Codex-driven workflows.
`;
}

function readmeForExport({ projectName, version, pipeline, template }) {
  const pipelineSummary = PIPELINE_PACKAGES[pipeline]?.summary ?? PIPELINE_PACKAGES[DEFAULT_PIPELINE].summary;
  return `# ${projectName} (Unity ${version})

This archive is generated by the Unity exporter stub to prime a ${pipelineSummary} project that Codex can extend.

## Contents
- ProjectSettings/ProjectVersion.txt pins the editor to **${version}** so Unity Hub selects the right install.
- Packages/manifest.json activates the ${pipelineSummary} dependencies plus core tooling.
- ProjectSettings/ProjectSettings.asset seeds quality defaults for desktop play mode.
- Assets/Scenes/${projectName}.unity is a placeholder scene tagged with the "${template}" template metadata.

## Next steps
1. Install Unity ${version} (or compatible) through Unity Hub and ensure the Editor path is registered.
2. Extract this archive into your workspace, then open it via **Unity Hub → Projects → Add project from disk**.
3. Use the prompts in \`codex/prompts/blackroad_high_impact_codex_prompts.prompt.md\` to have Codex scaffold gameplay systems, art passes, and simulation behaviors.
4. Commit the generated assets back to the BlackRoad repo and trigger any CI defined for Unity builds.

> Tip: keep both ${version} and ${DEFAULT_VERSION} on build agents so you can diff behavior between long-term support releases.
`;
}

app.post("/export", async (req, res) => {
  try {
    const { projectName, unityVersions, renderPipeline, template } = req.body ?? {};
    const safeProjectName = sanitizeProjectName(projectName);
    const pipeline = normalizePipeline(renderPipeline);
    const templateName = typeof template === "string" && template.trim() !== "" ? template.trim() : DEFAULT_TEMPLATE;
    const versions = coerceVersions(unityVersions);

    const outDir = path.join(process.cwd(), "downloads");
    await mkdir(outDir, { recursive: true });

    const exports = [];
    for (const version of versions) {
      const effectiveVersion = version || DEFAULT_VERSION;
      const zip = new JSZip();
      zip.file("ProjectSettings/ProjectVersion.txt", projectVersionFile(effectiveVersion));
      zip.file("ProjectSettings/ProjectSettings.asset", projectSettingsAsset(safeProjectName, pipeline));
      zip.file("Packages/manifest.json", manifestForPipeline(pipeline));
      zip.file(
        `Assets/Scenes/${safeProjectName}.unity`,
        placeholderScene({ projectName: safeProjectName, pipeline, template: templateName }),
      );
      zip.file(
        "README.md",
        readmeForExport({ projectName: safeProjectName, version: effectiveVersion, pipeline, template: templateName }),
      );

      const archive = await zip.generateAsync({ type: "nodebuffer", compression: "DEFLATE" });
      const zipFileName = `${safeProjectName}-${effectiveVersion}.zip`;
      const zipPath = path.join(outDir, zipFileName);
      await writeFile(zipPath, archive);
      exports.push({ version: effectiveVersion, path: zipPath });
    }

    res.json({
      ok: true,
      projectName: safeProjectName,
      renderPipeline: pipeline,
      template: templateName,
      exports,
    });
  } catch (error) {
    console.error("unity exporter failed", error);
    res.status(500).json({ ok: false, error: error instanceof Error ? error.message : String(error) });
  }
});

const port = process.env.PORT || 3000;
app.listen(port, () => console.log("unity exporter listening on", port));
