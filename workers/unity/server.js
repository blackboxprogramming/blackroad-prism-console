import express from "express";
import archiver from "archiver";
import crypto from "crypto";
import { createWriteStream } from "fs";
import { mkdtemp, mkdir, rm, writeFile } from "fs/promises";
import os from "os";
import path from "path";

const app = express();
app.use(express.json({ limit: "1mb" }));

const DEFAULT_SCENES = ["SampleScene"];

function slugify(input) {
  return input
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)+/g, "")
    .replace(/--+/g, "-")
    || "unity-project";
}

function sanitizeScenes(value) {
  if (!Array.isArray(value)) {
    return [...DEFAULT_SCENES];
  }
  const cleaned = value
    .map((scene) => (typeof scene === "string" ? scene.trim() : ""))
    .filter(Boolean);
  if (cleaned.length === 0) {
    return [...DEFAULT_SCENES];
  }
  return Array.from(new Set(cleaned));
}

function buildSceneContent(sceneName, projectName) {
  const lines = [
    `// Auto-generated scene stub for ${projectName}`,
    "%YAML 1.1",
    "%TAG !u! tag:unity3d.com,2011:",
    "--- !u!1 &1000",
    "GameObject:",
    "  m_ObjectHideFlags: 0",
    "  serializedVersion: 6",
    "  m_Component:",
    "  - component: {fileID: 400000}",
    "  m_Layer: 0",
    `  m_Name: ${sceneName}`,
    "  m_TagString: Untagged",
    "  m_Icon: {fileID: 0}",
    "  m_NavMeshLayer: 0",
    "  m_StaticEditorFlags: 0",
    "  m_IsActive: 1",
    "--- !u!4 &400000",
    "Transform:",
    "  m_ObjectHideFlags: 0",
    "  serializedVersion: 10",
    "  m_GameObject: {fileID: 1000}",
    "  m_LocalRotation: {x: 0, y: 0, z: 0, w: 1}",
    "  m_LocalPosition: {x: 0, y: 0, z: 0}",
    "  m_LocalScale: {x: 1, y: 1, z: 1}",
    "  m_Children: []",
    "  m_Father: {fileID: 0}",
    "  m_RootOrder: 0",
    "  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}",
  ];

  return `${lines.join("\n")}\n`;
}

function buildProjectSettings(projectName) {
  const lines = [
    "%YAML 1.1",
    "%TAG !u! tag:unity3d.com,2011:",
    "--- !u!129 &1",
    "PlayerSettings:",
    "  m_ObjectHideFlags: 0",
    "  serializedVersion: 23",
    `  productName: ${projectName}`,
    "  companyName: BlackRoad",
    "  defaultScreenWidth: 1920",
    "  defaultScreenHeight: 1080",
    "  runInBackground: 1",
    "  visibleInBackground: 1",
    "  allowFullscreenSwitch: 1",
    "  fullscreenMode: 1",
    "  bundleVersion: 0.1.0",
  ];

  return `${lines.join("\n")}\n`;
}

function buildEditorBuildSettings(scenes) {
  const sceneEntries = scenes.map((scene, index) => [
    "  - enabled: 1",
    `    path: Assets/Scenes/${scene}.unity`,
    `    guid: 0000000000000000000000000000000${index}`,
    "    addressable: 0",
    `    order: ${index}`,
  ]);

  const fallback = [
    "  - enabled: 1",
    "    path: Assets/Scenes/SampleScene.unity",
    "    guid: 00000000000000000000000000000000",
    "    addressable: 0",
    "    order: 0",
  ];

  const lines = [
    "%YAML 1.1",
    "%TAG !u! tag:unity3d.com,2011:",
    "--- !u!1045 &1",
    "EditorBuildSettings:",
    "  m_ObjectHideFlags: 0",
    "  serializedVersion: 2",
    "  m_Scenes:",
    ...((sceneEntries.length ? sceneEntries : [fallback]).flat()),
    "  m_configObjects: {}",
  ];

  return `${lines.join("\n")}\n`;
}

function buildReadme(projectName, description, scenes) {
  const content = [
    `# ${projectName}`,
    "",
    description || "This archive contains a starter Unity project generated by the BlackRoad Unity exporter.",
    "",
    "## Scenes",
    ...scenes.map((scene) => `- Assets/Scenes/${scene}.unity`),
    "",
    "## Next Steps",
    "1. Open the project in Unity 2022.3 LTS or newer.",
    "2. Replace the placeholder scenes with your gameplay content.",
    "3. Configure build targets (File â†’ Build Settings) and player options.",
    "4. Wire additional systems (input, lighting, audio) as needed.",
    "",
    "Generated by BlackRoad's Unity exporter service."
  ];

  return content.join("\n");
}

async function prepareUnityProject(projectRoot, projectName, scenes, description) {
  const assetsDir = path.join(projectRoot, "Assets");
  const scenesDir = path.join(assetsDir, "Scenes");
  const packagesDir = path.join(projectRoot, "Packages");
  const settingsDir = path.join(projectRoot, "ProjectSettings");

  await Promise.all([
    mkdir(scenesDir, { recursive: true }),
    mkdir(packagesDir, { recursive: true }),
    mkdir(settingsDir, { recursive: true }),
  ]);

  await Promise.all(
    scenes.map((scene) =>
      writeFile(path.join(scenesDir, `${scene}.unity`), buildSceneContent(scene, projectName))
    )
  );

  const manifest = {
    dependencies: {
      "com.unity.collab-proxy": "2.0.3",
      "com.unity.ide.rider": "3.0.24",
      "com.unity.ide.visualstudio": "2.0.22",
      "com.unity.test-framework": "1.1.33",
      "com.unity.textmeshpro": "3.0.6",
      "com.unity.timeline": "1.7.6",
    },
    registries: [],
  };

  await Promise.all([
    writeFile(path.join(projectRoot, "README.md"), buildReadme(projectName, description, scenes)),
    writeFile(path.join(settingsDir, "ProjectVersion.txt"), "m_EditorVersion: 2022.3.0f1\n"),
    writeFile(path.join(settingsDir, "ProjectSettings.asset"), buildProjectSettings(projectName)),
    writeFile(path.join(settingsDir, "EditorBuildSettings.asset"), buildEditorBuildSettings(scenes)),
    writeFile(path.join(packagesDir, "manifest.json"), `${JSON.stringify(manifest, null, 2)}\n`),
  ]);
}

async function createZipFromDirectory(sourceDir, zipPath) {
  await new Promise((resolve, reject) => {
    const output = createWriteStream(zipPath);
    const archive = archiver("zip", { zlib: { level: 9 } });

    output.on("close", resolve);
    output.on("error", reject);
    archive.on("error", reject);

    archive.pipe(output);
    archive.directory(sourceDir, false);
    archive.finalize();
  });
}

app.post("/export", async (req, res) => {
  const payload = req.body ?? {};
  const rawName = typeof payload.projectName === "string" && payload.projectName.trim().length > 0
    ? payload.projectName.trim()
    : "BlackRoad Unity Project";
  const description = typeof payload.description === "string" ? payload.description.trim() : "";
  const scenes = sanitizeScenes(payload.scenes);

  const projectName = rawName;
  const slug = slugify(projectName);
  const identifier = crypto.randomUUID().slice(0, 8);
  const fileName = `${slug}-${identifier}.zip`;
  const downloadsDir = path.join(process.cwd(), "downloads");

  let stagingRoot;

  try {
    stagingRoot = await mkdtemp(path.join(os.tmpdir(), "unity-export-"));
    const projectRoot = path.join(stagingRoot, slug);
    await prepareUnityProject(projectRoot, projectName, scenes, description);

    await mkdir(downloadsDir, { recursive: true });
    const zipPath = path.join(downloadsDir, fileName);
    await createZipFromDirectory(projectRoot, zipPath);

    res.json({
      ok: true,
      path: zipPath,
      fileName,
      projectName,
      scenes,
      description,
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    res.status(500).json({ ok: false, error: message });
  } finally {
    if (stagingRoot) {
      await rm(stagingRoot, { recursive: true, force: true });
    }
  }
});

const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log("Unity exporter listening on", port);
});
