'use strict';

const https = require('https');
const data = require('./data');
const { createJiraClientFromEnv } = require('./jira');

const RETRY_BASE_MINUTES = 10;
const RETRY_MAX_MINUTES = 60;
const QUEUE_BATCH_LIMIT = 20;
const SLACK_TIMEOUT_MS = 10_000;

let workerTimer = null;

function computeDelayMinutes(attempts) {
  const base = (attempts || 1) * RETRY_BASE_MINUTES;
  return Math.min(RETRY_MAX_MINUTES, Math.max(RETRY_BASE_MINUTES, base));
}

function formatError(err) {
  if (!err) return 'unknown error';
  if (typeof err === 'string') return err;
  if (err instanceof Error) return err.message || String(err);
  try {
    return JSON.stringify(err);
  } catch {
    return String(err);
  }
}

function sanitizeLabel(value) {
  if (!value) return null;
  const label = String(value)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 50);
  return label || null;
}

function escapeField(value) {
  return String(value ?? '')
    .replace(/`/g, '\\`')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

function escapeMultiline(value) {
  const text = value == null ? '' : String(value);
  if (!text) return '(not provided)';
  return text
    .split(/\r?\n/)
    .map((line) => escapeField(line))
    .join('\n');
}

function getJiraConfig() {
  const projectKey = (process.env.JIRA_PROJECT_KEY || '').trim();
  const issueType = ((process.env.JIRA_ISSUE_TYPE || '') || 'Task').trim() || 'Task';
  if (!projectKey) {
    throw new Error('jira project key not set');
  }
  return { projectKey, issueType };
}

function buildLabels(ruleId) {
  const labels = ['blackroad-exception', 'security-exception'];
  const normalized = sanitizeLabel(ruleId);
  if (normalized) labels.push(normalized);
  return labels;
}

function describeWindow(from, until) {
  const start = from ? new Date(from).toISOString() : '(approval time)';
  const end = until ? new Date(until).toISOString() : '(none)';
  return `${start} â†’ ${end}`;
}

async function attemptTicketCreation(exceptionId) {
  const claim = data.claimExceptionTicket(exceptionId, 'jira');
  if (!claim || !claim.exception) {
    throw new Error(`exception ${exceptionId} not found`);
  }

  const exception = claim.exception;

  if (claim.status === 'has_ticket') {
    return { outcome: 'exists', exception };
  }

  if (claim.status === 'pending' || claim.status === 'unavailable') {
    return { outcome: 'pending', exception };
  }

  if (exception.status !== 'approved') {
    data.releasePendingTicket(exceptionId);
    return {
      outcome: 'skipped',
      reason: `status=${exception.status}`,
      exception,
    };
  }

  const client = createJiraClientFromEnv();
  const { projectKey, issueType } = getJiraConfig();

  const summary = `[Exception] ${exception.rule_id} on ${exception.subject_type}:${exception.subject_id} (org=${exception.org_id})`;
  const window = describeWindow(exception.valid_from, exception.valid_until);
  const description = [
    `*Rule:* ${escapeField(exception.rule_id)}`,
    `*Org:* ${escapeField(exception.org_id)}`,
    `*Subject:* ${escapeField(exception.subject_type)}:${escapeField(exception.subject_id)}`,
    `*Requested by:* ${escapeField(exception.requested_by)}`,
    `*Window:* ${escapeField(window)}`,
    '',
    '*Reason:*',
    escapeMultiline(exception.reason),
    '',
    '(Generated by Blackroad exceptions service)',
  ].join('\n');

  let issue;
  try {
    issue = await client.createIssue(projectKey, issueType, summary, description, buildLabels(exception.rule_id));
  } catch (err) {
    data.releasePendingTicket(exceptionId);
    throw err;
  }

  const issueUrl = `${client.baseUrl.replace(/\/$/, '')}/browse/${issue.key}`;

  data.setExceptionTicket(exceptionId, 'jira', issue.key, issueUrl);
  data.recordExceptionEvent(exceptionId, 'system', 'ticket_create', `jira:${issue.key}`);

  await notifySlack(exceptionId, issueUrl, issue.key).catch((err) => {
    const message = formatError(err);
    try {
      data.recordExceptionEvent(exceptionId, 'system', 'ticket_slack_error', message);
    } catch (recordErr) {
      console.error('failed to record slack ticket error', recordErr); // eslint-disable-line no-console
    }
  });

  return { outcome: 'created', issue, exception: data.getException(exceptionId) };
}

function scheduleRetry(exceptionId, message, baseAttempts) {
  let attemptsSeed = typeof baseAttempts === 'number' ? baseAttempts : null;
  if (attemptsSeed == null) {
    const existing = data.getTicketQueueEntry(exceptionId);
    attemptsSeed = existing ? existing.attempts : 0;
  }
  const attempts = (attemptsSeed || 0) + 1;
  const delayMinutes = computeDelayMinutes(attempts);
  const entry = data.upsertTicketQueue(exceptionId, attempts, message, delayMinutes);
  return { entry, attempts, delayMinutes };
}

function scheduleTicketCreation(exceptionId) {
  if (!exceptionId) return;
  setImmediate(() => {
    attemptTicketCreation(exceptionId)
      .then((result) => {
        if (!result) return;
        if (result.outcome === 'skipped' && result.reason) {
          try {
            data.recordExceptionEvent(exceptionId, 'system', 'ticket_skip', result.reason);
          } catch (err) {
            console.error('failed to record ticket skip', err); // eslint-disable-line no-console
          }
        }
        if (result.outcome === 'created' || result.outcome === 'exists' || result.outcome === 'skipped') {
          data.deleteTicketQueueByException(exceptionId);
        }
      })
      .catch((err) => {
        const message = formatError(err);
        scheduleRetry(exceptionId, message);
        try {
          data.recordExceptionEvent(exceptionId, 'system', 'ticket_error', message);
        } catch (recordErr) {
          console.error('failed to record ticket error', recordErr); // eslint-disable-line no-console
        }
        console.error(`ticket creation failed for exception ${exceptionId}: ${message}`); // eslint-disable-line no-console
      });
  });
}

async function runTicketQueue() {
  const entries = data.getDueTicketQueue(QUEUE_BATCH_LIMIT);
  for (const entry of entries) {
    try {
      const result = await attemptTicketCreation(entry.exception_id);
      if (result && result.outcome === 'created') {
        data.deleteTicketQueue(entry.id);
      } else if (result && result.outcome === 'exists') {
        data.deleteTicketQueue(entry.id);
      } else if (result && result.outcome === 'skipped') {
        data.deleteTicketQueue(entry.id);
        if (result.reason) {
          try {
            data.recordExceptionEvent(entry.exception_id, 'system', 'ticket_skip', result.reason);
          } catch (err) {
            console.error('failed to record ticket skip', err); // eslint-disable-line no-console
          }
        }
      }
    } catch (err) {
      const message = formatError(err);
      scheduleRetry(entry.exception_id, message, entry.attempts);
      try {
        data.recordExceptionEvent(entry.exception_id, 'system', 'ticket_error', message);
      } catch (recordErr) {
        console.error('failed to record ticket error', recordErr); // eslint-disable-line no-console
      }
      console.error(`ticket queue attempt failed for exception ${entry.exception_id}: ${message}`); // eslint-disable-line no-console
    }
  }
}

function startTicketWorker(intervalMs) {
  if (workerTimer) return workerTimer;
  const envMs = Number(process.env.TICKET_QUEUE_INTERVAL_MS || 0);
  const envMinutes = Number(process.env.TICKET_QUEUE_INTERVAL_MINUTES || 0);
  const interval = Number.isFinite(intervalMs) && intervalMs > 0
    ? intervalMs
    : Number.isFinite(envMs) && envMs > 0
      ? envMs
      : Number.isFinite(envMinutes) && envMinutes > 0
        ? envMinutes * 60 * 1000
        : RETRY_BASE_MINUTES * 60 * 1000;

  runTicketQueue().catch((err) => {
    console.error('ticket queue initial run failed', err); // eslint-disable-line no-console
  });

  workerTimer = setInterval(() => {
    runTicketQueue().catch((err) => {
      console.error('ticket queue run failed', err); // eslint-disable-line no-console
    });
  }, interval);
  if (typeof workerTimer.unref === 'function') {
    workerTimer.unref();
  }
  return workerTimer;
}

function stopTicketWorker() {
  if (workerTimer) {
    clearInterval(workerTimer);
    workerTimer = null;
  }
}

function postSlackMessage(token, payload) {
  return new Promise((resolve, reject) => {
    const body = JSON.stringify(payload);
    const options = {
      method: 'POST',
      hostname: 'slack.com',
      path: '/api/chat.postMessage',
      headers: {
        Authorization: `Bearer ${token}`,
        'Content-Type': 'application/json; charset=utf-8',
        'Content-Length': Buffer.byteLength(body),
      },
    };
    const req = https.request(options, (res) => {
      let data = '';
      res.setEncoding('utf8');
      res.on('data', (chunk) => {
        data += chunk;
      });
      res.on('end', () => {
        if (res.statusCode && res.statusCode >= 400) {
          reject(new Error(`slack post returned ${res.statusCode}`));
          return;
        }
        let parsed;
        try {
          parsed = JSON.parse(data || '{}');
        } catch (err) {
          reject(err);
          return;
        }
        if (parsed.ok) {
          resolve(parsed);
        } else {
          reject(new Error(`slack post failed: ${parsed.error || 'unknown_error'}`));
        }
      });
    });
    req.on('error', reject);
    if (SLACK_TIMEOUT_MS) {
      req.setTimeout(SLACK_TIMEOUT_MS, () => {
        req.destroy(new Error('slack request timeout'));
      });
    }
    req.write(body);
    req.end();
  });
}

async function notifySlack(exceptionId, issueUrl, issueKey) {
  const token = (process.env.SLACK_BOT_TOKEN || '').trim();
  if (!token) return;
  const exception = data.getException(exceptionId);
  if (!exception) return;
  const channel =
    exception.slack_channel
    || (process.env.SLACK_TICKET_CHANNEL || '').trim()
    || (process.env.SECOPS_CHANNEL || '').trim();
  if (!channel) return;
  const payload = {
    channel,
    text: `:page_facing_up: Jira ticket created for exception #${exception.id}: <${issueUrl}|${issueKey}>`,
  };
  const thread = exception.slack_thread_ts || exception.slack_ts;
  if (thread) {
    payload.thread_ts = thread;
  }
  await postSlackMessage(token, payload);
}

module.exports = {
  attemptTicketCreation,
  scheduleTicketCreation,
  runTicketQueue,
  startTicketWorker,
  stopTicketWorker,
};
