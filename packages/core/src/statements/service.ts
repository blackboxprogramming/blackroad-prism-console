import { promises as fs } from 'fs';
import { join } from 'path';
import { DateTime } from 'luxon';
import { hashBuffer } from '../utils.js';
import type { PrismaClient } from '@blackroad/db';
import { WormLedger } from '@blackroad/worm';

const OUTPUT_DIR = process.env.CUSTODYSYNC_OUTPUT_DIR ?? 'artifacts/custodysync';

export class StatementService {
  constructor(private readonly prisma: PrismaClient, private readonly worm = new WormLedger(prisma)) {}

  async generateStatement(accountId: string, period: string): Promise<string> {
    const account = await this.prisma.account.findUniqueOrThrow({ where: { id: accountId } });
    const blockingBreak = await this.prisma.reconBreak.findFirst({
      where: {
        accountId,
        severity: { gte: 80 },
        status: 'OPEN',
        asOf: { lt: DateTime.now().minus({ days: 2 }).toJSDate() }
      }
    });
    if (blockingBreak) {
      throw new Error(`Cannot generate statement while severe break ${blockingBreak.id} remains open.`);
    }
    const [year, quarter] = period.match(/(\d{4})Q(\d)/)?.slice(1) ?? [];
    const periodStart = quarter
      ? DateTime.fromObject({ year: Number(year), month: (Number(quarter) - 1) * 3 + 1, day: 1 })
      : DateTime.fromISO(`${period}-01`);
    const periodEnd = quarter ? periodStart.plus({ months: 3 }).minus({ days: 1 }) : periodStart.endOf('month');

    const holdings = await this.prisma.positionSnapshot.findMany({
      where: { accountId, asOf: periodEnd.toJSDate() }
    });
    const transactions = await this.prisma.transaction.findMany({
      where: {
        accountId,
        tradeDate: {
          gte: periodStart.toJSDate(),
          lte: periodEnd.toJSDate()
        }
      },
      orderBy: { tradeDate: 'asc' }
    });
    const proofs = await this.prisma.document.findMany({ where: { accountId, kind: 'PROOF_OF_RESERVES' } });

    const lines: string[] = [];
    lines.push(`BlackRoad Finance Statement`);
    lines.push(`Account: ${account.accountNo}`);
    lines.push(`Owner: ${account.ownerId}`);
    lines.push(`Period: ${periodStart.toISODate()} - ${periodEnd.toISODate()}`);
    lines.push('');
    lines.push('Holdings:');
    holdings.forEach((holding) => {
      lines.push(` - ${holding.instrumentId}: ${holding.quantity.toString()} units @ ${holding.price.toString()}`);
    });
    lines.push('');
    lines.push('Activity:');
    transactions.forEach((tx) => {
      lines.push(` - ${DateTime.fromJSDate(tx.tradeDate).toISODate()} ${tx.type} ${tx.netAmount.toString()} ${tx.currency}`);
    });
    if (proofs.length > 0) {
      lines.push('');
      lines.push('Proof of Reserves:');
      proofs.forEach((doc) => {
        const meta = (doc.meta ?? {}) as Record<string, any>;
        lines.push(` - ${meta['provider'] ?? 'Unknown'} (${meta['asOf'] ?? ''}) -> ${doc.path}`);
      });
    }
    lines.push('');
    lines.push('Disclosures: Generated by CustodySync beta. Not for distribution.');

    const buffer = Buffer.from(lines.join('\n'), 'utf-8');
    const relPath = join('statements', `${accountId}_${period}.pdf`);
    const outPath = join(OUTPUT_DIR, relPath);
    await fs.mkdir(join(OUTPUT_DIR, 'statements'), { recursive: true });
    await fs.writeFile(outPath, buffer);
    const sha = hashBuffer(buffer);

    const document = await this.prisma.document.create({
      data: {
        accountId,
        kind: 'STATEMENT',
        path: outPath,
        sha256: sha,
        meta: {
          period,
          generatedAt: new Date().toISOString()
        }
      }
    });

    await this.worm.append({
      documentId: document.id,
      payload: {
        type: 'STATEMENT_GENERATED',
        accountId,
        period,
        path: relPath,
        sha
      }
    });

    return outPath;
  }

  async generateConfirm(transactionId: string): Promise<string> {
    const transaction = await this.prisma.transaction.findUniqueOrThrow({ where: { id: transactionId } });
    const account = await this.prisma.account.findUniqueOrThrow({ where: { id: transaction.accountId } });
    const instrument = transaction.instrumentId
      ? await this.prisma.instrument.findUnique({ where: { id: transaction.instrumentId } })
      : null;

    const lines = [
      'BlackRoad Finance Trade Confirmation',
      `Account: ${account.accountNo}`,
      `Trade Date: ${transaction.tradeDate.toISOString()}`,
      `Type: ${transaction.type}`,
      `Quantity: ${transaction.quantity ?? ''}`,
      `Price: ${transaction.price ?? ''}`,
      `Instrument: ${instrument?.symbol ?? instrument?.ticker ?? transaction.instrumentId ?? 'N/A'}`
    ];

    const buffer = Buffer.from(lines.join('\n'), 'utf-8');
    const relPath = join('confirms', `${transactionId}.pdf`);
    const outPath = join(OUTPUT_DIR, relPath);
    await fs.mkdir(join(OUTPUT_DIR, 'confirms'), { recursive: true });
    await fs.writeFile(outPath, buffer);
    const sha = hashBuffer(buffer);

    const document = await this.prisma.document.create({
      data: {
        accountId: transaction.accountId,
        kind: 'CONFIRM',
        path: outPath,
        sha256: sha,
        meta: {
          transactionId,
          generatedAt: new Date().toISOString()
        }
      }
    });

    await this.worm.append({
      documentId: document.id,
      payload: {
        type: 'TRADE_CONFIRM_GENERATED',
        transactionId,
        accountId: transaction.accountId,
        sha,
        path: relPath
      }
    });

    return outPath;
  }
}
