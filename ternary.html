<!doctype html>

<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ternary Quantum Consciousness Framework</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>

    <script>
    // --- Console-only runtime self-checks ---
    // --- Console-only runtime sanity checks ---
    (function(){
      const log = console.log.bind(console, '[runtime]');
      const warn = console.warn.bind(console, '[runtime]');
      const error = console.error.bind(console, '[runtime]');

      try {
        if (!window.Chart) error('Chart.js missing');
        else log('Chart.js OK');

        if (!window.math || !math.expm) error('math.js missing or no expm');
        else {
          // quick unitary check
          // quick unitary sanity
          const H = math.matrix([[1,0.1,0],[0.1,0,-0.2],[0,-0.2,-0.9]]);
          const U  = math.expm(math.multiply(math.complex(0,-1), H));
          const Ud = math.ctranspose(U);
          const I  = math.identity(3);
          const frob = (()=>{ const D = math.subtract(math.multiply(Ud,U), I); return Math.sqrt(math.sum(math.dotMultiply(D, math.conj(D)))); })();
          if (frob > 1e-6) warn(`Unitary borderline: ||U‚Ä†U‚àíI||‚âà${frob.toExponential(2)}`); else log('Unitary OK');
        }

        // density check
        // density sanity
        if (window.math) {
          const psi = math.divide(math.matrix([1,1,1]), Math.sqrt(3));
          const rho = math.multiply(math.reshape(psi,[3,1]), math.ctranspose(math.reshape(psi,[3,1])));
          const tr  = math.trace(rho); const pur = math.trace(math.multiply(rho,rho));
          if (Math.abs((tr.re ?? tr)-1) > 1e-8) error(`Tr(œÅ)=${tr}`);
          else log('Tr(œÅ)=1 OK');
          const p = (pur.re ?? pur);
          if (p<1/3-1e-6 || p>1+1e-6) error(`Purity out-of-bounds: ${p}`); else log(`Purity OK (${p.toFixed(4)})`);
        }

        // minimal paint timing
        try {
          new PerformanceObserver((list) => {
            list.getEntries().forEach((e) => {
              if (e.name === 'first-contentful-paint') {
                const t = e.startTime.toFixed(0);
                if (e.startTime > 2500) warn(`FCP ${t}ms (slow)`); else log(`FCP ${t}ms`);
              }
            });
          }).observe({ type: 'paint', buffered: true });
        } catch {}
      } catch (e) {
        error('Self-check error', e);
      }

      window.onerror = function(msg, src, line, col){
        console.error('[runtime] Global error:', msg, src, line, col);
      };
    })();
    </script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
        line-height: 1.6;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }

      .header {
        text-align: center;
        color: white;
        padding: 30px 0;
        margin-bottom: 30px;
      }

      .header h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .header p {
        font-size: 1.2rem;
        opacity: 0.9;
      }

      .controls {
        background: white;
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 30px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .control-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }

      .control-group {
        display: flex;
        flex-direction: column;
      }

      .control-group label {
        font-weight: bold;
        color: #5a67d8;
        margin-bottom: 5px;
      }

      .control-group input,
      .control-group select {
        padding: 10px;
        border: 2px solid #e2e8f0;
        border-radius: 8px;
        font-size: 14px;
        transition: border-color 0.3s;
      }

      .control-group input:focus,
      .control-group select:focus {
        outline: none;
        border-color: #5a67d8;
      }

      .preset-buttons {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 15px;
      }

      .preset-btn {
        padding: 8px 16px;
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        border: none;
        border-radius: 20px;
        cursor: pointer;
        font-size: 14px;
        transition:
          transform 0.3s,
          box-shadow 0.3s;
      }

      .preset-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }

      .dashboard {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .card {
        background: white;
        border-radius: 15px;
        padding: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        transition:
          transform 0.3s,
          box-shadow 0.3s;
      }

      .card:hover {
        transform: translateY(-5px);
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
      }

      .card h3 {
        color: #5a67d8;
        margin-bottom: 15px;
        font-size: 1.3rem;
      }

      .chart-container {
        position: relative;
        height: 300px;
        margin-bottom: 15px;
      }

      .metrics {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
        margin-top: 15px;
      }

      .metric {
        background: linear-gradient(135deg, #f7fafc, #edf2f7);
        padding: 15px;
        border-radius: 10px;
        text-align: center;
      }

      .metric-value {
        font-size: 1.5rem;
        font-weight: bold;
        color: #5a67d8;
      }

      .metric-label {
        font-size: 0.9rem;
        color: #666;
        margin-top: 5px;
      }

      .ternary-display {
        display: flex;
        justify-content: space-around;
        margin: 20px 0;
      }

      .ternary-state {
        text-align: center;
        padding: 15px;
        border-radius: 10px;
        background: linear-gradient(135deg, #f7fafc, #edf2f7);
        flex: 1;
        margin: 0 5px;
      }

      .ternary-state.active {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
      }

      .state-label {
        font-weight: bold;
        margin-bottom: 5px;
      }

      .state-probability {
        font-size: 1.2rem;
        color: #5a67d8;
      }

      .ternary-state.active .state-probability {
        color: white;
      }

      .evolution-controls {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin: 15px 0;
      }

      .btn {
        padding: 10px 20px;
        background: linear-gradient(45deg, #667eea, #764ba2);
        color: white;
        border: none;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.3s;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      }

      .btn:disabled {
        background: #ccc;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }

      .creative-energy-viz {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .energy-surface {
        width: 100%;
        height: 400px;
        border: 1px solid #ddd;
        border-radius: 10px;
        background: linear-gradient(45deg, #f0f8ff, #e6f3ff);
      }

      .consciousness-nav {
        background: white;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      }

      .nav-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
      }

      @media (max-width: 768px) {
        .dashboard {
          grid-template-columns: 1fr;
        }

        .control-grid {
          grid-template-columns: 1fr;
        }

        .nav-grid {
          grid-template-columns: 1fr;
        }
      }

      .formula {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        font-family: 'Courier New', monospace;
        margin: 10px 0;
        border-left: 4px solid #5a67d8;
      }

      .highlight {
        animation: glow 2s ease-in-out infinite alternate;
      }

      @keyframes glow {
        from {
          box-shadow: 0 0 5px rgba(102, 126, 234, 0.3);
        }
        to {
          box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üß† Ternary Quantum Consciousness Framework</h1>
        <p>Interactive exploration of three-state quantum systems for consciousness navigation</p>
      </div>

      <div class="controls">
        <h3>üéõÔ∏è Quantum State Configuration</h3>
        <div class="control-grid">
          <div class="control-group">
            <label>Amplitude Œ± (|-1‚ü© state):</label>
            <input type="range" id="alpha" min="0" max="1" step="0.01" value="0.577" />
            <span id="alphaValue">0.577</span>
          </div>
          <div class="control-group">
            <label>Amplitude Œ≤ (|0‚ü© state):</label>
            <input type="range" id="beta" min="0" max="1" step="0.01" value="0.577" />
            <span id="betaValue">0.577</span>
          </div>
          <div class="control-group">
            <label>Amplitude Œ≥ (|+1‚ü© state):</label>
            <input type="range" id="gamma" min="0" max="1" step="0.01" value="0.577" />
            <span id="gammaValue">0.577</span>
          </div>
          <div class="control-group">
            <label>Evolution Time:</label>
            <input type="range" id="time" min="0" max="6.28" step="0.1" value="0" />
            <span id="timeValue">0.0</span>
          </div>
        </div>

        <div class="preset-buttons">
          <button class="preset-btn" onclick="setPreset('balanced')">Balanced State</button>
          <button class="preset-btn" onclick="setPreset('focused')">Focused State</button>
          <button class="preset-btn" onclick="setPreset('creative')">Creative State</button>
          <button class="preset-btn" onclick="setPreset('meditative')">Meditative State</button>
        </div>
      </div>

      <div class="dashboard">
        <div class="card">
          <h3>üî¨ Quantum State Probabilities</h3>
          <div class="ternary-display" id="ternaryDisplay">
            <div class="ternary-state" id="state-1">
              <div class="state-label">|-1‚ü©</div>
              <div class="state-probability" id="prob-1">0.333</div>
            </div>
            <div class="ternary-state" id="state0">
              <div class="state-label">|0‚ü©</div>
              <div class="state-probability" id="prob0">0.333</div>
            </div>
            <div class="ternary-state" id="state1">
              <div class="state-label">|+1‚ü©</div>
              <div class="state-probability" id="prob1">0.333</div>
            </div>
          </div>
          <div class="chart-container">
            <canvas id="probabilityChart"></canvas>
          </div>
        </div>

        <div class="card">
          <h3>üìä Information Measures</h3>
          <div class="metrics">
            <div class="metric">
              <div class="metric-value" id="entropy">1.099</div>
              <div class="metric-label">Von Neumann Entropy</div>
            </div>
            <div class="metric">
              <div class="metric-value" id="purity">0.333</div>
              <div class="metric-label">Quantum Purity</div>
            </div>
            <div class="metric">
              <div class="metric-value" id="uncertainty">0.125</div>
              <div class="metric-label">Uncertainty Product</div>
            </div>
            <div class="metric">
              <div class="metric-value" id="consciousness">0.750</div>
              <div class="metric-label">Consciousness Score</div>
            </div>
          </div>
          <div class="formula">
            H = -Tr(œÅ log œÅ)<br />
            P = Tr(œÅ¬≤)<br />
            ŒîA¬∑ŒîB¬∑ŒîC ‚â• ‚Ñè¬≥/8
          </div>
        </div>

        <div class="card">
          <h3>‚ö° Boundary Creative Energy</h3>
          <div class="chart-container">
            <canvas id="creativeEnergyChart"></canvas>
          </div>
          <div class="formula">K_c = [œÉc(1+Œ≥)(1+ œá|Œ¥u|)] / [1+ Œª|Œ¥u|]</div>
          <div class="metrics">
            <div class="metric">
              <div class="metric-value" id="maxCreative">2.340</div>
              <div class="metric-label">Peak Energy</div>
            </div>
            <div class="metric">
              <div class="metric-value" id="optimalDelta">1.500</div>
              <div class="metric-label">Optimal Œ¥u</div>
            </div>
          </div>
        </div>

        <div class="card">
          <h3>üîÑ Quantum Evolution</h3>
          <div class="evolution-controls">
            <button class="btn" id="playBtn" onclick="toggleEvolution()">‚ñ∂Ô∏è Play</button>
            <button class="btn" onclick="resetEvolution()">üîÑ Reset</button>
          </div>
          <div class="chart-container">
            <canvas id="evolutionChart"></canvas>
          </div>
        </div>
      </div>

      <div class="consciousness-nav">
        <h3>üß≠ Consciousness Navigation</h3>
        <div class="nav-grid">
          <div>
            <h4>Navigation Paths</h4>
            <div class="chart-container">
              <canvas id="navigationChart"></canvas>
            </div>
          </div>
          <div>
            <h4>Capability Ratios</h4>
            <div class="chart-container">
              <canvas id="capabilityChart"></canvas>
            </div>
          </div>
        </div>
      </div>

      <div class="creative-energy-viz">
        <h3>üåä Creative Energy Landscape</h3>
        <div class="chart-container">
          <canvas id="energyLandscape"></canvas>
        </div>
      </div>
    </div>

    <script>
      // Core ternary quantum system implementation
      class TernaryQubit {
        constructor(amplitudes) {
          this.amplitudes = this.normalize(amplitudes);
        }

        normalize(amplitudes) {
          const norm = Math.sqrt(amplitudes.reduce((sum, a) => sum + a * a, 0));
          return norm > 0 ? amplitudes.map((a) => a / norm) : amplitudes;
        }

        get probabilities() {
          return this.amplitudes.map((a) => a * a);
        }

        get vonNeumannEntropy() {
          const probs = this.probabilities;
          return -probs.reduce((sum, p) => {
            return sum + (p > 1e-10 ? p * Math.log(p) : 0);
          }, 0);
        }

        get purity() {
          const probs = this.probabilities;
          return probs.reduce((sum, p) => sum + p * p, 0);
        }

        measure() {
          const probs = this.probabilities;
          const rand = Math.random();
          let cumulative = 0;

          for (let i = 0; i < probs.length; i++) {
            cumulative += probs[i];
            if (rand <= cumulative) {
              return [-1, 0, 1][i];
            }
          }
          return 1;
        }
      }

      class BoundaryCreativeEnergy {
        static calculate(sigmaC, gamma, chi, lambda, deltaU) {
          const numerator = sigmaC * (1 + gamma) * (1 + chi * Math.abs(deltaU));
          const denominator = 1 + lambda * Math.abs(deltaU);
          return numerator / denominator;
        }
      }

      class TernaryLogicGates {
        static TAND(a, b) {
          return Math.min(a, b);
        }

        static TOR(a, b) {
          return Math.max(a, b);
        }

        static TNOT(a) {
          return -a;
        }
      }

      // Global state
      let currentState = new TernaryQubit([1 / Math.sqrt(3), 1 / Math.sqrt(3), 1 / Math.sqrt(3)]);
      let evolutionAnimation = null;
      let isPlaying = false;
      let charts = {};

      // Initialize the application
      function initializeApp() {
        setupCharts();
        setupControls();
        updateDisplay();
        generateCreativeEnergyLandscape();
        generateNavigationData();
      }

      function setupControls() {
        ['alpha', 'beta', 'gamma', 'time'].forEach((id) => {
          const slider = document.getElementById(id);
          const valueSpan = document.getElementById(id + 'Value');

          slider.addEventListener('input', (e) => {
            valueSpan.textContent = parseFloat(e.target.value).toFixed(3);
            if (id !== 'time') {
              updateQuantumState();
            } else {
              updateEvolution();
            }
          });
        });
      }

      function setupCharts() {
        // Probability chart
        const probCtx = document.getElementById('probabilityChart').getContext('2d');
        charts.probability = new Chart(probCtx, {
          type: 'doughnut',
          data: {
            labels: ['|-1‚ü©', '|0‚ü©', '|+1‚ü©'],
            datasets: [
              {
                data: [0.333, 0.333, 0.333],
                backgroundColor: ['#ff6b6b', '#4ecdc4', '#45b7d1'],
                borderWidth: 2,
                borderColor: '#fff',
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                position: 'bottom',
              },
            },
          },
        });

        // Creative energy chart
        const energyCtx = document.getElementById('creativeEnergyChart').getContext('2d');
        const deltaRange = Array.from({ length: 50 }, (_, i) => i * 0.1);
        const energyData = deltaRange.map((delta) =>
          BoundaryCreativeEnergy.calculate(1.0, 0.5, 0.3, 0.2, delta)
        );

        charts.creativeEnergy = new Chart(energyCtx, {
          type: 'line',
          data: {
            labels: deltaRange,
            datasets: [
              {
                label: 'Creative Energy K_c',
                data: energyData,
                borderColor: '#9c27b0',
                backgroundColor: 'rgba(156, 39, 176, 0.1)',
                borderWidth: 3,
                fill: true,
                tension: 0.4,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                title: {
                  display: true,
                  text: 'Boundary Displacement (Œ¥u)',
                },
              },
              y: {
                title: {
                  display: true,
                  text: 'Creative Energy (K_c)',
                },
              },
            },
          },
        });

        // Update creative energy metrics
        const maxEnergy = Math.max(...energyData);
        const optimalDelta = deltaRange[energyData.indexOf(maxEnergy)];
        document.getElementById('maxCreative').textContent = maxEnergy.toFixed(3);
        document.getElementById('optimalDelta').textContent = optimalDelta.toFixed(3);

        // Evolution chart
        const evolutionCtx = document.getElementById('evolutionChart').getContext('2d');
        charts.evolution = new Chart(evolutionCtx, {
          type: 'line',
          data: {
            labels: [],
            datasets: [
              {
                label: '|-1‚ü©',
                data: [],
                borderColor: '#ff6b6b',
                backgroundColor: 'rgba(255, 107, 107, 0.1)',
                borderWidth: 2,
              },
              {
                label: '|0‚ü©',
                data: [],
                borderColor: '#4ecdc4',
                backgroundColor: 'rgba(78, 205, 196, 0.1)',
                borderWidth: 2,
              },
              {
                label: '|+1‚ü©',
                data: [],
                borderColor: '#45b7d1',
                backgroundColor: 'rgba(69, 183, 209, 0.1)',
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                title: {
                  display: true,
                  text: 'Time',
                },
              },
              y: {
                title: {
                  display: true,
                  text: 'Probability',
                },
                min: 0,
                max: 1,
              },
            },
            animation: {
              duration: 0,
            },
          },
        });
      }

      function updateQuantumState() {
        const alpha = parseFloat(document.getElementById('alpha').value);
        const beta = parseFloat(document.getElementById('beta').value);
        const gamma = parseFloat(document.getElementById('gamma').value);

        currentState = new TernaryQubit([alpha, beta, gamma]);
        updateDisplay();
      }

      function updateDisplay() {
        const probs = currentState.probabilities;

        // Update probability displays
        document.getElementById('prob-1').textContent = probs[0].toFixed(3);
        document.getElementById('prob0').textContent = probs[1].toFixed(3);
        document.getElementById('prob1').textContent = probs[2].toFixed(3);

        // Highlight dominant state
        ['state-1', 'state0', 'state1'].forEach((id, index) => {
          const element = document.getElementById(id);
          if (probs[index] === Math.max(...probs)) {
            element.classList.add('active');
          } else {
            element.classList.remove('active');
          }
        });

        // Update chart
        charts.probability.data.datasets[0].data = probs;
        charts.probability.update('none');

        // Update metrics
        document.getElementById('entropy').textContent = currentState.vonNeumannEntropy.toFixed(3);
        document.getElementById('purity').textContent = currentState.purity.toFixed(3);

        // Calculate uncertainty product (simplified)
        const uncertaintyProduct = calculateUncertaintyProduct(currentState);
        document.getElementById('uncertainty').textContent = uncertaintyProduct.toFixed(3);

        // Calculate consciousness score
        const consciousnessScore = calculateConsciousnessScore(currentState);
        document.getElementById('consciousness').textContent = consciousnessScore.toFixed(3);
      }

      function calculateUncertaintyProduct(state) {
        // Simplified three-way uncertainty calculation
        const probs = state.probabilities;
        const entropy = state.vonNeumannEntropy;
        // Approximate uncertainty based on entropy and purity
        return Math.max(0.125, entropy * state.purity * 0.2);
      }

      function calculateConsciousnessScore(state) {
        const entropy = state.vonNeumannEntropy;
        const purity = state.purity;
        const uncertainty = calculateUncertaintyProduct(state);

        // Weighted combination
        return 0.4 * entropy + 0.3 * (1 - purity) + 0.3 * uncertainty;
      }

      function setPreset(type) {
        let amplitudes;

        switch (type) {
          case 'balanced':
            amplitudes = [1 / Math.sqrt(3), 1 / Math.sqrt(3), 1 / Math.sqrt(3)];
            break;
          case 'focused':
            amplitudes = [0.8, 0.1, 0.1];
            break;
          case 'creative':
            amplitudes = [0.2, 0.3, 0.5];
            break;
          case 'meditative':
            amplitudes = [0.1, 0.8, 0.1];
            break;
        }

        // Update sliders
        document.getElementById('alpha').value = amplitudes[0];
        document.getElementById('beta').value = amplitudes[1];
        document.getElementById('gamma').value = amplitudes[2];

        // Update displays
        document.getElementById('alphaValue').textContent = amplitudes[0].toFixed(3);
        document.getElementById('betaValue').textContent = amplitudes[1].toFixed(3);
        document.getElementById('gammaValue').textContent = amplitudes[2].toFixed(3);

        updateQuantumState();
      }

      function updateEvolution() {
        const time = parseFloat(document.getElementById('time').value);

        // Simulate quantum evolution with simple oscillation
        const omega1 = 1.0,
          omega2 = 2.0,
          omega3 = 3.0;
        const initialAmps = [
          parseFloat(document.getElementById('alpha').value),
          parseFloat(document.getElementById('beta').value),
          parseFloat(document.getElementById('gamma').value),
        ];

        // Simple evolution simulation
        const evolvedAmps = [
          initialAmps[0] * Math.cos(omega1 * time),
          initialAmps[1] * Math.cos(omega2 * time),
          initialAmps[2] * Math.cos(omega3 * time),
        ];

        const evolvedState = new TernaryQubit(evolvedAmps);

        // Update temporary display
        const probs = evolvedState.probabilities;
        document.getElementById('prob-1').textContent = probs[0].toFixed(3);
        document.getElementById('prob0').textContent = probs[1].toFixed(3);
        document.getElementById('prob1').textContent = probs[2].toFixed(3);

        charts.probability.data.datasets[0].data = probs;
        charts.probability.update('none');
      }

      function toggleEvolution() {
        if (isPlaying) {
          stopEvolution();
        } else {
          startEvolution();
        }
      }

      function startEvolution() {
        isPlaying = true;
        document.getElementById('playBtn').innerHTML = '‚è∏Ô∏è Pause';

        const timeSlider = document.getElementById('time');
        const startTime = parseFloat(timeSlider.value);
        const maxTime = parseFloat(timeSlider.max);

        let currentTime = startTime;
        const timeStep = 0.1;

        charts.evolution.data.labels = [];
        charts.evolution.data.datasets.forEach((dataset) => (dataset.data = []));

        evolutionAnimation = setInterval(() => {
          if (currentTime >= maxTime) {
            currentTime = 0;
            charts.evolution.data.labels = [];
            charts.evolution.data.datasets.forEach((dataset) => (dataset.data = []));
          }

          timeSlider.value = currentTime;
          document.getElementById('timeValue').textContent = currentTime.toFixed(1);

          updateEvolution();

          // Add data to evolution chart
          const probs = [
            parseFloat(document.getElementById('prob-1').textContent),
            parseFloat(document.getElementById('prob0').textContent),
            parseFloat(document.getElementById('prob1').textContent),
          ];

          charts.evolution.data.labels.push(currentTime.toFixed(1));
          charts.evolution.data.datasets[0].data.push(probs[0]);
          charts.evolution.data.datasets[1].data.push(probs[1]);
          charts.evolution.data.datasets[2].data.push(probs[2]);

          // Keep only last 50 points
          if (charts.evolution.data.labels.length > 50) {
            charts.evolution.data.labels.shift();
            charts.evolution.data.datasets.forEach((dataset) => dataset.data.shift());
          }

          charts.evolution.update('none');

          currentTime += timeStep;
        }, 100);
      }

      function stopEvolution() {
        isPlaying = false;
        document.getElementById('playBtn').innerHTML = '‚ñ∂Ô∏è Play';

        if (evolutionAnimation) {
          clearInterval(evolutionAnimation);
          evolutionAnimation = null;
        }
      }

      function resetEvolution() {
        stopEvolution();
        document.getElementById('time').value = 0;
        document.getElementById('timeValue').textContent = '0.0';

        charts.evolution.data.labels = [];
        charts.evolution.data.datasets.forEach((dataset) => (dataset.data = []));
        charts.evolution.update('none');

        updateQuantumState();
      }

      function generateCreativeEnergyLandscape() {
        const ctx = document.getElementById('energyLandscape').getContext('2d');

        // Create a heatmap-style visualization
        const width = 400;
        const height = 300;
        const imageData = ctx.createImageData(width, height);

        let maxEnergy = 0;
        const energyValues = [];

        // Calculate energy landscape
        for (let y = 0; y < height; y++) {
          energyValues[y] = [];
          for (let x = 0; x < width; x++) {
            const deltaU1 = (x - width / 2) / (width / 4);
            const deltaU2 = (y - height / 2) / (height / 4);
            const deltaU = Math.sqrt(deltaU1 * deltaU1 + deltaU2 * deltaU2);

            // Vary parameters for interesting landscape
            const sigmaC = 1.0 + 0.3 * Math.sin(deltaU1);
            const gamma = 0.5 + 0.2 * Math.cos(deltaU2);

            const energy = BoundaryCreativeEnergy.calculate(sigmaC, gamma, 0.3, 0.2, deltaU);
            energyValues[y][x] = energy;
            maxEnergy = Math.max(maxEnergy, energy);
          }
        }

        // Convert to colors
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const energy = energyValues[y][x];
            const normalized = energy / maxEnergy;

            const pixelIndex = (y * width + x) * 4;

            // Plasma-like colormap
            const r = Math.floor(255 * Math.sin(normalized * Math.PI));
            const g = Math.floor(255 * Math.sin(normalized * Math.PI + 2));
            const b = Math.floor(255 * Math.sin(normalized * Math.PI + 4));

            imageData.data[pixelIndex] = Math.abs(r);
            imageData.data[pixelIndex + 1] = Math.abs(g);
            imageData.data[pixelIndex + 2] = Math.abs(b);
            imageData.data[pixelIndex + 3] = 255;
          }
        }

        ctx.putImageData(imageData, 0, 0);

        // Add contour lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;

        const contourLevels = [0.2, 0.4, 0.6, 0.8];
        contourLevels.forEach((level) => {
          const threshold = level * maxEnergy;
          ctx.beginPath();

          // Simple contour tracing (simplified)
          for (let y = 1; y < height - 1; y += 5) {
            for (let x = 1; x < width - 1; x += 5) {
              if (Math.abs(energyValues[y][x] - threshold) < maxEnergy * 0.05) {
                ctx.arc(x, y, 1, 0, 2 * Math.PI);
              }
            }
          }
          ctx.stroke();
        });
      }

      function generateNavigationData() {
        // Consciousness states in 3D space
        const consciousnessStates = {
          Anxious: [2.0, -1.5, 0.5],
          Calm: [0.0, 0.0, 0.0],
          Focused: [-1.0, 2.0, 1.0],
          Creative: [1.5, 1.0, 2.5],
        };

        // Navigation chart (2D projection)
        const navCtx = document.getElementById('navigationChart').getContext('2d');
        charts.navigation = new Chart(navCtx, {
          type: 'scatter',
          data: {
            datasets: [
              {
                label: 'Consciousness States',
                data: Object.entries(consciousnessStates).map(([name, pos]) => ({
                  x: pos[0],
                  y: pos[1],
                  label: name,
                })),
                backgroundColor: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#ffa726'],
                borderColor: ['#ff5252', '#26a69a', '#1e88e5', '#ff9800'],
                borderWidth: 2,
                pointRadius: 8,
              },
              {
                label: 'Navigation Paths',
                data: [
                  { x: 2.0, y: -1.5 },
                  { x: 0.0, y: 0.0 }, // Anxious to Calm
                  { x: 0.0, y: 0.0 },
                  { x: -1.0, y: 2.0 }, // Calm to Focused
                  { x: -1.0, y: 2.0 },
                  { x: 1.5, y: 1.0 }, // Focused to Creative
                ],
                borderColor: '#9c27b0',
                backgroundColor: 'rgba(156, 39, 176, 0.1)',
                borderWidth: 2,
                pointRadius: 0,
                showLine: true,
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                title: {
                  display: true,
                  text: 'Consciousness Dimension 1',
                },
              },
              y: {
                title: {
                  display: true,
                  text: 'Consciousness Dimension 2',
                },
              },
            },
            plugins: {
              tooltip: {
                callbacks: {
                  label: function (context) {
                    if (context.dataset.label === 'Consciousness States') {
                      return context.parsed.label || `(${context.parsed.x}, ${context.parsed.y})`;
                    }
                    return `(${context.parsed.x}, ${context.parsed.y})`;
                  },
                },
              },
            },
          },
        });

        // Capability ratios chart
        const capCtx = document.getElementById('capabilityChart').getContext('2d');
        const transitions = [
          'Anxious‚ÜíCalm',
          'Calm‚ÜíFocused',
          'Focused‚ÜíCreative',
          'Anxious‚ÜíCreative',
        ];
        const capabilityRatios = [1.2, 0.8, 1.5, 2.1]; // Example values

        charts.capability = new Chart(capCtx, {
          type: 'bar',
          data: {
            labels: transitions,
            datasets: [
              {
                label: 'Capability Ratio',
                data: capabilityRatios,
                backgroundColor: [
                  'rgba(255, 107, 107, 0.7)',
                  'rgba(78, 205, 196, 0.7)',
                  'rgba(69, 183, 209, 0.7)',
                  'rgba(255, 167, 38, 0.7)',
                ],
                borderColor: ['#ff5252', '#26a69a', '#1e88e5', '#ff9800'],
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                title: {
                  display: true,
                  text: 'Capability Ratio',
                },
                beginAtZero: true,
              },
            },
          },
        });
      }

      // Quantum measurement simulation
      function performMeasurement() {
        const result = currentState.measure();

        // Visual feedback
        const resultElement = document.createElement('div');
        resultElement.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #667eea, #764ba2);
                color: white;
                padding: 20px 40px;
                border-radius: 15px;
                font-size: 24px;
                font-weight: bold;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                z-index: 1000;
                animation: measurementPop 1s ease-out forwards;
            `;

        // Add CSS animation
        const style = document.createElement('style');
        style.textContent = `
                @keyframes measurementPop {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
                }
            `;
        document.head.appendChild(style);

        resultElement.textContent = `Measured: |${result}‚ü©`;
        document.body.appendChild(resultElement);

        setTimeout(() => {
          document.body.removeChild(resultElement);
          document.head.removeChild(style);
        }, 1000);
      }

      // Add measurement button functionality
      function addMeasurementButton() {
        const measureBtn = document.createElement('button');
        measureBtn.textContent = 'üéØ Measure State';
        measureBtn.className = 'btn';
        measureBtn.style.margin = '10px';
        measureBtn.onclick = performMeasurement;

        const evolutionControls = document.querySelector('.evolution-controls');
        evolutionControls.appendChild(measureBtn);
      }

      // Ternary logic gate testing
      function testTernaryLogic() {
        const gates = TernaryLogicGates;
        const testResults = [];

        for (let a of [-1, 0, 1]) {
          for (let b of [-1, 0, 1]) {
            testResults.push({
              a: a,
              b: b,
              tand: gates.TAND(a, b),
              tor: gates.TOR(a, b),
              tnot_a: gates.TNOT(a),
            });
          }
        }

        console.log('Ternary Logic Gate Results:', testResults);
        return testResults;
      }

      // Enhanced consciousness scoring
      function updateConsciousnessMetrics() {
        const state = currentState;
        const probs = state.probabilities;

        // Advanced metrics
        const entropy = state.vonNeumannEntropy;
        const purity = state.purity;

        // Information integration (simplified Œ¶)
        const phi = calculatePhi(probs);

        // Global workspace integration
        const globalIntegration = calculateGlobalIntegration(probs);

        // Update display with enhanced metrics
        document.getElementById('consciousness').textContent = (
          0.3 * entropy +
          0.25 * phi +
          0.25 * globalIntegration +
          0.2 * (1 - purity)
        ).toFixed(3);
      }

      function calculatePhi(probabilities) {
        // Simplified integrated information measure
        // Based on the KL divergence between full system and parts
        const uniform = [1 / 3, 1 / 3, 1 / 3];
        let kl_div = 0;

        for (let i = 0; i < probabilities.length; i++) {
          if (probabilities[i] > 0) {
            kl_div += probabilities[i] * Math.log(probabilities[i] / uniform[i]);
          }
        }

        return Math.max(0, kl_div);
      }

      function calculateGlobalIntegration(probabilities) {
        // Measure of how well information is integrated across states
        const maxProb = Math.max(...probabilities);
        const minProb = Math.min(...probabilities);

        // Higher integration when probabilities are more balanced
        return 1 - (maxProb - minProb);
      }

      // Real-time parameter exploration
      function setupRealTimeExploration() {
        const params = ['sigma_c', 'gamma_param', 'chi', 'lambda'];

        params.forEach((param) => {
          const slider = document.createElement('input');
          slider.type = 'range';
          slider.id = param;
          slider.min = '0';
          slider.max = '2';
          slider.step = '0.1';
          slider.value = param === 'sigma_c' ? '1.0' : '0.5';

          slider.addEventListener('input', updateCreativeEnergyParams);

          // Add to controls (if there was space)
        });
      }

      function updateCreativeEnergyParams() {
        // This would update the creative energy visualization in real-time
        // Implementation would depend on having the parameter controls
      }

      // Enhanced evolution with realistic Hamiltonian
      function createRealisticHamiltonian() {
        // Create a more realistic 3x3 Hamiltonian with interesting dynamics
        return [
          [1.0, 0.1, 0.05],
          [0.1, 1.5, 0.1],
          [0.05, 0.1, 2.0],
        ];
      }

      function calculateQuantumEvolution(hamiltonian, state, time) {
        // Simplified quantum evolution calculation
        // In practice, this would involve matrix exponentiation
        const eigenfreqs = [1.0, 1.5, 2.0]; // Diagonal approximation

        const evolvedAmps = state.amplitudes.map((amp, i) => {
          const phase = eigenfreqs[i] * time;
          return amp * Math.cos(phase);
        });

        return new TernaryQubit(evolvedAmps);
      }

      // Add keyboard shortcuts
      function setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          switch (e.key) {
            case ' ':
              e.preventDefault();
              toggleEvolution();
              break;
            case 'r':
              resetEvolution();
              break;
            case 'm':
              performMeasurement();
              break;
            case '1':
              setPreset('focused');
              break;
            case '2':
              setPreset('balanced');
              break;
            case '3':
              setPreset('creative');
              break;
            case '4':
              setPreset('meditative');
              break;
          }
        });
      }

      // Initialize everything when the page loads
      document.addEventListener('DOMContentLoaded', () => {
        initializeApp();
        addMeasurementButton();
        setupKeyboardShortcuts();
        testTernaryLogic();

        // Add helpful tooltips
        addTooltips();

        console.log('üß† Ternary Quantum Consciousness Framework Initialized!');
        console.log('Keyboard shortcuts:');
        console.log('  Space: Play/Pause evolution');
        console.log('  R: Reset evolution');
        console.log('  M: Measure quantum state');
        console.log('  1-4: Set presets (Focused, Balanced, Creative, Meditative)');
      });

      function addTooltips() {
        // Add helpful tooltips to explain the concepts
        const tooltips = {
          entropy: 'Von Neumann entropy measures quantum uncertainty',
          purity: 'Quantum purity indicates how "mixed" the state is',
          uncertainty: 'Three-way uncertainty product ŒîA¬∑ŒîB¬∑ŒîC',
          consciousness: 'Integrated consciousness score combining multiple measures',
        };

        Object.entries(tooltips).forEach(([id, text]) => {
          const element = document.getElementById(id);
          if (element) {
            element.title = text;
          }
        });
      }

      // Export data functionality
      function exportData() {
        const data = {
          currentState: {
            amplitudes: currentState.amplitudes,
            probabilities: currentState.probabilities,
            entropy: currentState.vonNeumannEntropy,
            purity: currentState.purity,
          },
          timestamp: new Date().toISOString(),
          framework: 'Ternary Quantum Consciousness',
        };

        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = 'consciousness_state_data.json';
        link.click();

        URL.revokeObjectURL(url);
      }

      // Add export button
      function addExportButton() {
        const exportBtn = document.createElement('button');
        exportBtn.textContent = 'üíæ Export Data';
        exportBtn.className = 'btn';
        exportBtn.style.margin = '10px';
        exportBtn.onclick = exportData;

        const evolutionControls = document.querySelector('.evolution-controls');
        evolutionControls.appendChild(exportBtn);
      }

      // Call this after DOM loads
      setTimeout(() => {
        addExportButton();
      }, 100);
    </script>
    <!-- Runtime Self-Check Badge -->
    <style id="runtimeCheckStyles">
      #runtimeSelfCheck {
        position: fixed;
        right: 14px;
        top: 14px;
        z-index: 9999;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        font-size: 12px;
        line-height: 1.3;
        background: #0f172a;
        color: #e2e8f0;
        padding: 8px 10px;
        border-radius: 10px;
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        opacity: 0.95;
        cursor: pointer;
      }
      #runtimeSelfCheck.ok {
        border: 2px solid #22c55e;
      }
      #runtimeSelfCheck.warn {
        border: 2px solid #f59e0b;
      }
      #runtimeSelfCheck.error {
        border: 2px solid #ef4444;
      }
      #runtimeSelfCheck details {
        max-width: 320px;
      }
      #runtimeSelfCheck summary {
        outline: none;
      }
    </style>
    <div id="runtimeSelfCheck" class="warn">
      <details>
        <summary>Runtime checks‚Ä¶</summary>
        <div id="runtimeSelfCheckBody">running‚Ä¶</div>
      </details>
    </div>

    <script>
      (function () {
        const el = document.getElementById('runtimeSelfCheck');
        const out = document.getElementById('runtimeSelfCheckBody');
        let fail = 0,
          warn = 0,
          logs = [];
        const log = (icon, msg) => logs.push(`${icon} ${msg}`);
        const setState = () => {
          el.classList.remove('ok', 'warn', 'error');
          el.classList.add(fail ? 'error' : warn ? 'warn' : 'ok');
          el.querySelector('summary').textContent = fail
            ? `Runtime: FAIL (${fail})`
            : warn
              ? `Runtime: WARN`
              : 'Runtime: OK';
          out.innerHTML = logs.map((l) => `<div>${l}</div>`).join('');
        };
        const approxEqual = (a, b, eps = 1e-6) => Math.abs(a - b) <= eps;

        try {
          // 1) Libraries present
          if (!window.Chart) {
            fail++;
            log('‚ùå', 'Chart.js not found');
          } else {
            log('‚úÖ', 'Chart.js present');
          }
          if (!window.math) {
            fail++;
            log('‚ùå', 'math.js not found');
          } else {
            log('‚úÖ', 'math.js present');
          }

          // 2) math.js expm check + unitary verification
          // 2) math.js expm sanity + unitary check
          if (window.math && math.expm) {
            const H = math.matrix([
              [1, 0.2, 0],
              [0.2, 0, -0.1],
              [0, -0.1, -0.8],
            ]);
            const U = math.expm(math.multiply(math.complex(0, -1), H)); // e^{-iHt}
            const Ud = math.ctranspose(U);
            const I = math.identity(3);
            const UU = math.multiply(Ud, U);
            // ||UU - I||_F
            const diff = math.subtract(UU, I);
            const frob = Math.sqrt(math.sum(math.dotMultiply(diff, math.conj(diff))));
            if (frob > 1e-6) {
              warn++;
              log('‚ö†Ô∏è', `Unitary check borderline (||U‚Ä†U‚àíI||‚âà${frob.toExponential(2)})`);
            } else {
              log('‚úÖ', 'Unitary check passed');
            }
          } else {
            warn++;
            log('‚ö†Ô∏è', 'math.expm unavailable');
          }

          // 3) Density matrix check (trace‚âà1, 1/3‚â§Tr(œÅ¬≤)‚â§1)
          // 3) Density matrix sanity (trace‚âà1, 1/3‚â§Tr(œÅ¬≤)‚â§1)
          if (window.math) {
            const psi = math.divide(math.matrix([1, 1, 1]), Math.sqrt(3)); // balanced
            const rho = math.multiply(
              math.reshape(psi, [3, 1]),
              math.ctranspose(math.reshape(psi, [3, 1]))
            );
            const tr = math.trace(rho);
            const pur = math.trace(math.multiply(rho, rho));
            if (!approxEqual(tr.re ?? tr, 1, 1e-8)) {
              fail++;
              log('‚ùå', `Tr(œÅ)=${tr.re ?? tr} ‚â† 1`);
            } else log('‚úÖ', 'Tr(œÅ)=1');
            const pval = pur.re ?? pur;
            if (pval < 1 / 3 - 1e-6 || pval > 1 + 1e-6) {
              fail++;
              log('‚ùå', `Purity out of bounds: ${pval}`);
            } else log('‚úÖ', `Purity sane (${pval.toFixed(4)})`);
          }

          // 4) Chart create/destroy (offscreen)
          if (window.Chart) {
            const c = document.createElement('canvas');
            c.width = 200;
            c.height = 80;
            c.style.display = 'none';
            document.body.appendChild(c);
            let ok = true;
            try {
              const ctx = c.getContext('2d');
              const tmp = new Chart(ctx, {
                type: 'line',
                data: { labels: [0, 1], datasets: [{ data: [0, 1] }] },
                options: { animation: false },
              });
              tmp.destroy();
            } catch (e) {
              ok = false;
              console.error(e);
            }
            if (!ok) {
              fail++;
              log('‚ùå', 'Chart.js failed to render');
            } else {
              log('‚úÖ', 'Chart render ok');
            }
            c.remove();
          }

          // 5) Frame loop / timing check
          // 5) Frame loop / timing sanity
          let rafHit = false;
          const p1 = new Promise((res) =>
            requestAnimationFrame(() => {
              rafHit = true;
              res();
            })
          );
          const p2 = new Promise((res) => setTimeout(res, 50));
          Promise.race([p1, p2]).then(() => {
            if (!rafHit) {
              warn++;
              log('‚ö†Ô∏è', 'requestAnimationFrame slow/blocked');
            } else {
              log('‚úÖ', 'Animation tick ok');
            }
            setState();
          });

          // 6) Global error trap
          window.onerror = function (msg, src, line, col) {
            fail++;
            log('‚ùå', `JS error: ${String(msg)} (${src}:${line}:${col})`);
            setState();
          };
        } catch (e) {
          fail++;
          log('‚ùå', `Self-check exception: ${(e && e.message) || e}`);
          setState();
        }

        // Toggle collapsed/expanded on click
        el.addEventListener('click', () => {
          const det = el.querySelector('details');
          if (!det.open) det.open = true;
        });

        // Initial UI
        setState();
      })();
    </script>
  </body>

    <script>
    // --- Performance Budget: warn if slow (non-fatal) ---
    (function(){
      const B = {
        fp_ms: 2000,        // First Paint budget
        fcp_ms: 2500,       // First Contentful Paint budget
        longtask_ms: 100,   // Long task threshold
        total_long_ms: 600  // Total long-task time budget
      };
      let longTaskTotal = 0;

      // Paint timing
      new PerformanceObserver((list) => {
        list.getEntries().forEach((e) => {
          if (e.name === 'first-paint' && e.startTime > B.fp_ms) {
            console.warn(`[perf] FP ${e.startTime.toFixed(0)}ms exceeds ${B.fp_ms}ms`);
            markBadgeWarn(`FP ${e.startTime.toFixed(0)}ms > ${B.fp_ms}ms`);
          }
          if (e.name === 'first-contentful-paint' && e.startTime > B.fcp_ms) {
            console.warn(`[perf] FCP ${e.startTime.toFixed(0)}ms exceeds ${B.fcp_ms}ms`);
            markBadgeWarn(`FCP ${e.startTime.toFixed(0)}ms > ${B.fcp_ms}ms`);
          }
        });
      }).observe({ type: 'paint', buffered: true });

      // Long tasks (main thread)
      if ('PerformanceObserver' in window && 'PerformanceLongTaskTiming' in window) {
        new PerformanceObserver((list) => {
          list.getEntries().forEach((t) => {
            const d = t.duration;
            if (d >= B.longtask_ms) {
              longTaskTotal += d;
              console.warn(`[perf] Long task ${d.toFixed(0)}ms (total ${longTaskTotal.toFixed(0)}ms)`);
              if (longTaskTotal > B.total_long_ms) {
                markBadgeWarn(`Long tasks total ${longTaskTotal.toFixed(0)}ms > ${B.total_long_ms}ms`);
              }
            }
          });
        }).observe({entryTypes:['longtask']});
      }

      function markBadgeWarn(msg){
        const badge = document.getElementById('runtimeSelfCheck');
        if (!badge) return;
        badge.classList.remove('ok');
        if (!badge.classList.contains('error')) badge.classList.add('warn');
        const body = document.getElementById('runtimeSelfCheckBody');
        if (body) body.insertAdjacentHTML('beforeend', `<div>‚ö†Ô∏è ${msg}</div>`);
      }
    })();
    </script>
</body>
</html>
