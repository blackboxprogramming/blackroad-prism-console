<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ternary Quantum Consciousness Framework</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>

    <script>
    // --- Console-only runtime sanity checks ---
    (function(){
      const log = console.log.bind(console, '[runtime]');
      const warn = console.warn.bind(console, '[runtime]');
      const error = console.error.bind(console, '[runtime]');

      try {
        if (!window.Chart) error('Chart.js missing');
        else log('Chart.js OK');

        if (!window.math || !math.expm) error('math.js missing or no expm');
        else {
          // quick unitary sanity
          const H = math.matrix([[1,0.1,0],[0.1,0,-0.2],[0,-0.2,-0.9]]);
          const U  = math.expm(math.multiply(math.complex(0,-1), H));
          const Ud = math.ctranspose(U);
          const I  = math.identity(3);
          const frob = (()=>{ const D = math.subtract(math.multiply(Ud,U), I); return Math.sqrt(math.sum(math.dotMultiply(D, math.conj(D)))); })();
          if (frob > 1e-6) warn(`Unitary borderline: ||U‚Ä†U‚àíI||‚âà${frob.toExponential(2)}`); else log('Unitary OK');
        }

        // density sanity
        if (window.math) {
          const psi = math.divide(math.matrix([1,1,1]), Math.sqrt(3));
          const rho = math.multiply(math.reshape(psi,[3,1]), math.ctranspose(math.reshape(psi,[3,1])));
          const tr  = math.trace(rho); const pur = math.trace(math.multiply(rho,rho));
          if (Math.abs((tr.re ?? tr)-1) > 1e-8) error(`Tr(œÅ)=${tr}`);
          else log('Tr(œÅ)=1 OK');
          const p = (pur.re ?? pur);
          if (p<1/3-1e-6 || p>1+1e-6) error(`Purity out-of-bounds: ${p}`); else log(`Purity OK (${p.toFixed(4)})`);
        }

        // minimal paint timing
        try {
          new PerformanceObserver((list) => {
            list.getEntries().forEach((e) => {
              if (e.name === 'first-contentful-paint') {
                const t = e.startTime.toFixed(0);
                if (e.startTime > 2500) warn(`FCP ${t}ms (slow)`); else log(`FCP ${t}ms`);
              }
            });
          }).observe({ type: 'paint', buffered: true });
        } catch {}
      } catch (e) {
        error('Self-check error', e);
      }

      window.onerror = function(msg, src, line, col){
        console.error('[runtime] Global error:', msg, src, line, col);
      };
    })();
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            padding: 30px 0;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: bold;
            color: #5a67d8;
            margin-bottom: 5px;
        }

        .control-group input, .control-group select {
            padding: 10px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #5a67d8;
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .preset-btn {
            padding: 8px 16px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .preset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .dashboard {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.15);
        }

        .card h3 {
            color: #5a67d8;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin-bottom: 15px;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .metric {
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #5a67d8;
        }

        .metric-label {
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .ternary-display {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }

        .ternary-state {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            flex: 1;
            margin: 0 5px;
        }

        .ternary-state.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .state-label {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .state-probability {
            font-size: 1.2rem;
            color: #5a67d8;
        }

        .ternary-state.active .state-probability {
            color: white;
        }

        .evolution-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 15px 0;
        }

        .btn {
            padding: 10px 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .creative-energy-viz {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .energy-surface {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background: linear-gradient(45deg, #f0f8ff, #e6f3ff);
        }

        .consciousness-nav {
            background: white;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .nav-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }

        @media (max-width: 768px) {
            .dashboard {
                grid-template-columns: 1fr;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .nav-grid {
                grid-template-columns: 1fr;
            }
        }

        .formula {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 10px 0;
            border-left: 4px solid #5a67d8;
        }

        .highlight {
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { box-shadow: 0 0 5px rgba(102, 126, 234, 0.3); }
            to { box-shadow: 0 0 20px rgba(102, 126, 234, 0.6); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß† Ternary Quantum Consciousness Framework</h1>
            <p>Interactive exploration of three-state quantum systems for consciousness navigation</p>
        </div>

        <div class="controls">
            <h3>üéõÔ∏è Quantum State Configuration</h3>
            <div class="control-grid">
                <div class="control-group">
                    <label>Amplitude Œ± (|-1‚ü© state):</label>
                    <input type="range" id="alpha" min="0" max="1" step="0.01" value="0.577">
                    <span id="alphaValue">0.577</span>
                </div>
                <div class="control-group">
                    <label>Amplitude Œ≤ (|0‚ü© state):</label>
                    <input type="range" id="beta" min="0" max="1" step="0.01" value="0.577">
                    <span id="betaValue">0.577</span>
                </div>
                <div class="control-group">
                    <label>Amplitude Œ≥ (|+1‚ü© state):</label>
                    <input type="range" id="gamma" min="0" max="1" step="0.01" value="0.577">
                    <span id="gammaValue">0.577</span>
                </div>
                <div class="control-group">
                    <label>Evolution Time:</label>
                    <input type="range" id="time" min="0" max="6.28" step="0.1" value="0">
                    <span id="timeValue">0.0</span>
                </div>
            </div>
            
            <div class="preset-buttons">
                <button class="preset-btn" onclick="setPreset('balanced')">Balanced State</button>
                <button class="preset-btn" onclick="setPreset('focused')">Focused State</button>
                <button class="preset-btn" onclick="setPreset('creative')">Creative State</button>
                <button class="preset-btn" onclick="setPreset('meditative')">Meditative State</button>
            </div>
        </div>

        <div class="dashboard">
            <div class="card">
                <h3>üî¨ Quantum State Probabilities</h3>
                <div class="ternary-display" id="ternaryDisplay">
                    <div class="ternary-state" id="state-1">
                        <div class="state-label">|-1‚ü©</div>
                        <div class="state-probability" id="prob-1">0.333</div>
                    </div>
                    <div class="ternary-state" id="state0">
                        <div class="state-label">|0‚ü©</div>
                        <div class="state-probability" id="prob0">0.333</div>
                    </div>
                    <div class="ternary-state" id="state1">
                        <div class="state-label">|+1‚ü©</div>
                        <div class="state-probability" id="prob1">0.333</div>
                    </div>
                </div>
                <div class="chart-container">
                    <canvas id="probabilityChart"></canvas>
                </div>
            </div>

            <div class="card">
                <h3>üìä Information Measures</h3>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="entropy">1.099</div>
                        <div class="metric-label">Von Neumann Entropy</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="purity">0.333</div>
                        <div class="metric-label">Quantum Purity</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="uncertainty">0.125</div>
                        <div class="metric-label">Uncertainty Product</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="consciousness">0.750</div>
                        <div class="metric-label">Consciousness Score</div>
                    </div>
                </div>
                <div class="formula">
                    H = -Tr(œÅ log œÅ)<br>
                    P = Tr(œÅ¬≤)<br>
                    ŒîA¬∑ŒîB¬∑ŒîC ‚â• ‚Ñè¬≥/8
                </div>
            </div>

            <div class="card">
                <h3>‚ö° Boundary Creative Energy</h3>
                <div class="chart-container">
                    <canvas id="creativeEnergyChart"></canvas>
                </div>
                <div class="formula">
                    K_c = [œÉc(1+Œ≥)(1+ œá|Œ¥u|)] / [1+ Œª|Œ¥u|]
                </div>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="maxCreative">2.340</div>
                        <div class="metric-label">Peak Energy</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="optimalDelta">1.500</div>
                        <div class="metric-label">Optimal Œ¥u</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>üîÑ Quantum Evolution</h3>
                <div class="evolution-controls">
                    <button class="btn" id="playBtn" onclick="toggleEvolution()">‚ñ∂Ô∏è Play</button>
                    <button class="btn" onclick="resetEvolution()">üîÑ Reset</button>
                </div>
                <div class="chart-container">
                    <canvas id="evolutionChart"></canvas>
                </div>
            </div>
        </div>

        <div class="consciousness-nav">
            <h3>üß≠ Consciousness Navigation</h3>
            <div class="nav-grid">
                <div>
                    <h4>Navigation Paths</h4>
                    <div class="chart-container">
                        <canvas id="navigationChart"></canvas>
                    </div>
                </div>
                <div>
                    <h4>Capability Ratios</h4>
                    <div class="chart-container">
                        <canvas id="capabilityChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="creative-energy-viz">
            <h3>üåä Creative Energy Landscape</h3>
            <div class="chart-container">
                <canvas id="energyLandscape"></canvas>
            </div>
        </div>
    </div>

    <script>
        // Core ternary quantum system implementation
        class TernaryQubit {
            constructor(amplitudes) {
                this.amplitudes = this.normalize(amplitudes);
            }

            normalize(amplitudes) {
                const norm = Math.sqrt(amplitudes.reduce((sum, a) => sum + a * a, 0));
                return norm > 0 ? amplitudes.map(a => a / norm) : amplitudes;
            }

            get probabilities() {
                return this.amplitudes.map(a => a * a);
            }

            get vonNeumannEntropy() {
                const probs = this.probabilities;
                return -probs.reduce((sum, p) => {
                    return sum + (p > 1e-10 ? p * Math.log(p) : 0);
                }, 0);
            }

            get purity() {
                const probs = this.probabilities;
                return probs.reduce((sum, p) => sum + p * p, 0);
            }

            measure() {
                const probs = this.probabilities;
                const rand = Math.random();
                let cumulative = 0;
                
                for (let i = 0; i < probs.length; i++) {
                    cumulative += probs[i];
                    if (rand <= cumulative) {
                        return [-1, 0, 1][i];
                    }
                }
                return 1;
            }
        }

        class BoundaryCreativeEnergy {
            static calculate(sigmaC, gamma, chi, lambda, deltaU) {
                const numerator = sigmaC * (1 + gamma) * (1 + chi * Math.abs(deltaU));
                const denominator = 1 + lambda * Math.abs(deltaU);
                return numerator / denominator;
            }
        }

        class TernaryLogicGates {
            static TAND(a, b) {
                return Math.min(a, b);
            }

            static TOR(a, b) {
                return Math.max(a, b);
            }

            static TNOT(a) {
                return -a;
            }
        }

        // Global state
        let currentState = new TernaryQubit([1/Math.sqrt(3), 1/Math.sqrt(3), 1/Math.sqrt(3)]);
        let evolutionAnimation = null;
        let isPlaying = false;
        let charts = {};

        // Initialize the application
        function initializeApp() {
            setupCharts();
            setupControls();
            updateDisplay();
            generateCreativeEnergyLandscape();
            generateNavigationData();
        }

        function setupControls() {
            ['alpha', 'beta', 'gamma', 'time'].forEach(id => {
                const slider = document.getElementById(id);
                const valueSpan = document.getElementById(id + 'Value');
                
                slider.addEventListener('input', (e) => {
                    valueSpan.textContent = parseFloat(e.target.value).toFixed(3);
                    if (id !== 'time') {
                        updateQuantumState();
                    } else {
                        updateEvolution();
                    }
                });
            });
        }

        function setupCharts() {
            // Probability chart
            const probCtx = document.getElementById('probabilityChart').getContext('2d');
            charts.probability = new Chart(probCtx, {
                type: 'doughnut',
                data: {
                    labels: ['|-1‚ü©', '|0‚ü©', '|+1‚ü©'],
                    datasets: [{
                        data: [0.333, 0.333, 0.333],
                        backgroundColor: ['#ff6b6b', '#4ecdc4', '#45b7d1'],
                        borderWidth: 2,
                        borderColor: '#fff'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });

            // Creative energy chart
            const energyCtx = document.getElementById('creativeEnergyChart').getContext('2d');
            const deltaRange = Array.from({length: 50}, (_, i) => i * 0.1);
            const energyData = deltaRange.map(delta => 
                BoundaryCreativeEnergy.calculate(1.0, 0.5, 0.3, 0.2, delta)
            );

            charts.creativeEnergy = new Chart(energyCtx, {
                type: 'line',
                data: {
                    labels: deltaRange,
                    datasets: [{
                        label: 'Creative Energy K_c',
                        data: energyData,
                        borderColor: '#9c27b0',
                        backgroundColor: 'rgba(156, 39, 176, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Boundary Displacement (Œ¥u)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Creative Energy (K_c)'
                            }
                        }
                    }
                }
            });

            // Update creative energy metrics
            const maxEnergy = Math.max(...energyData);
            const optimalDelta = deltaRange[energyData.indexOf(maxEnergy)];
            document.getElementById('maxCreative').textContent = maxEnergy.toFixed(3);
            document.getElementById('optimalDelta').textContent = optimalDelta.toFixed(3);

            // Evolution chart
            const evolutionCtx = document.getElementById('evolutionChart').getContext('2d');
            charts.evolution = new Chart(evolutionCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: '|-1‚ü©',
                            data: [],
                            borderColor: '#ff6b6b',
                            backgroundColor: 'rgba(255, 107, 107, 0.1)',
                            borderWidth: 2
                        },
                        {
                            label: '|0‚ü©',
                            data: [],
                            borderColor: '#4ecdc4',
                            backgroundColor: 'rgba(78, 205, 196, 0.1)',
                            borderWidth: 2
                        },
                        {
                            label: '|+1‚ü©',
                            data: [],
                            borderColor: '#45b7d1',
                            backgroundColor: 'rgba(69, 183, 209, 0.1)',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Probability'
                            },
                            min: 0,
                            max: 1
                        }
                    },
                    animation: {
                        duration: 0
                    }
                }
            });
        }

        function updateQuantumState() {
            const alpha = parseFloat(document.getElementById('alpha').value);
            const beta = parseFloat(document.getElementById('beta').value);
            const gamma = parseFloat(document.getElementById('gamma').value);

            currentState = new TernaryQubit([alpha, beta, gamma]);
            updateDisplay();
        }

        function updateDisplay() {
            const probs = currentState.probabilities;
            
            // Update probability displays
            document.getElementById('prob-1').textContent = probs[0].toFixed(3);
            document.getElementById('prob0').textContent = probs[1].toFixed(3);
            document.getElementById('prob1').textContent = probs[2].toFixed(3);

            // Highlight dominant state
            ['state-1', 'state0', 'state1'].forEach((id, index) => {
                const element = document.getElementById(id);
                if (probs[index] === Math.max(...probs)) {
                    element.classList.add('active');
                } else {
                    element.classList.remove('active');
                }
            });

            // Update chart
            charts.probability.data.datasets[0].data = probs;
            charts.probability.update('none');

            // Update metrics
            document.getElementById('entropy').textContent = currentState.vonNeumannEntropy.toFixed(3);
            document.getElementById('purity').textContent = currentState.purity.toFixed(3);

            // Calculate uncertainty product (simplified)
            const uncertaintyProduct = calculateUncertaintyProduct(currentState);
            document.getElementById('uncertainty').textContent = uncertaintyProduct.toFixed(3);

            // Calculate consciousness score
            const consciousnessScore = calculateConsciousnessScore(currentState);
            document.getElementById('consciousness').textContent = consciousnessScore.toFixed(3);
        }

        function calculateUncertaintyProduct(state) {
            // Simplified three-way uncertainty calculation
            const probs = state.probabilities;
            const entropy = state.vonNeumannEntropy;
            // Approximate uncertainty based on entropy and purity
            return Math.max(0.125, entropy * state.purity * 0.2);
        }

        function calculateConsciousnessScore(state) {
            const entropy = state.vonNeumannEntropy;
            const purity = state.purity;
            const uncertainty = calculateUncertaintyProduct(state);
            
            // Weighted combination
            return 0.4 * entropy + 0.3 * (1 - purity) + 0.3 * uncertainty;
        }

        function setPreset(type) {
            let amplitudes;
            
            switch(type) {
                case 'balanced':
                    amplitudes = [1/Math.sqrt(3), 1/Math.sqrt(3), 1/Math.sqrt(3)];
                    break;
                case 'focused':
                    amplitudes = [0.8, 0.1, 0.1];
                    break;
                case 'creative':
                    amplitudes = [0.2, 0.3, 0.5];
                    break;
                case 'meditative':
                    amplitudes = [0.1, 0.8, 0.1];
                    break;
            }
            
            // Update sliders
            document.getElementById('alpha').value = amplitudes[0];
            document.getElementById('beta').value = amplitudes[1];
            document.getElementById('gamma').value = amplitudes[2];
            
            // Update displays
            document.getElementById('alphaValue').textContent = amplitudes[0].toFixed(3);
            document.getElementById('betaValue').textContent = amplitudes[1].toFixed(3);
            document.getElementById('gammaValue').textContent = amplitudes[2].toFixed(3);
            
            updateQuantumState();
        }

        function updateEvolution() {
            const time = parseFloat(document.getElementById('time').value);
            
            // Simulate quantum evolution with simple oscillation
            const omega1 = 1.0, omega2 = 2.0, omega3 = 3.0;
            const initialAmps = [
                parseFloat(document.getElementById('alpha').value),
                parseFloat(document.getElementById('beta').value),
                parseFloat(document.getElementById('gamma').value)
            ];
            
            // Simple evolution simulation
            const evolvedAmps = [
                initialAmps[0] * Math.cos(omega1 * time),
                initialAmps[1] * Math.cos(omega2 * time),
                initialAmps[2] * Math.cos(omega3 * time)
            ];
            
            const evolvedState = new TernaryQubit(evolvedAmps);
            
            // Update temporary display
            const probs = evolvedState.probabilities;
            document.getElementById('prob-1').textContent = probs[0].toFixed(3);
            document.getElementById('prob0').textContent = probs[1].toFixed(3);
            document.getElementById('prob1').textContent = probs[2].toFixed(3);
            
            charts.probability.data.datasets[0].data = probs;
            charts.probability.update('none');
        }

        function toggleEvolution() {
            if (isPlaying) {
                stopEvolution();
            } else {
                startEvolution();
            }
        }

        function startEvolution() {
            isPlaying = true;
            document.getElementById('playBtn').innerHTML = '‚è∏Ô∏è Pause';
            
            const timeSlider = document.getElementById('time');
            const startTime = parseFloat(timeSlider.value);
            const maxTime = parseFloat(timeSlider.max);
            
            let currentTime = startTime;
            const timeStep = 0.1;
            
            charts.evolution.data.labels = [];
            charts.evolution.data.datasets.forEach(dataset => dataset.data = []);
            
            evolutionAnimation = setInterval(() => {
                if (currentTime >= maxTime) {
                    currentTime = 0;
                    charts.evolution.data.labels = [];
                    charts.evolution.data.datasets.forEach(dataset => dataset.data = []);
                }
                
                timeSlider.value = currentTime;
                document.getElementById('timeValue').textContent = currentTime.toFixed(1);
                
                updateEvolution();
                
                // Add data to evolution chart
                const probs = [
                    parseFloat(document.getElementById('prob-1').textContent),
                    parseFloat(document.getElementById('prob0').textContent),
                    parseFloat(document.getElementById('prob1').textContent)
                ];
                
                charts.evolution.data.labels.push(currentTime.toFixed(1));
                charts.evolution.data.datasets[0].data.push(probs[0]);
                charts.evolution.data.datasets[1].data.push(probs[1]);
                charts.evolution.data.datasets[2].data.push(probs[2]);
                
                // Keep only last 50 points
                if (charts.evolution.data.labels.length > 50) {
                    charts.evolution.data.labels.shift();
                    charts.evolution.data.datasets.forEach(dataset => dataset.data.shift());
                }
                
                charts.evolution.update('none');
                
                currentTime += timeStep;
            }, 100);
        }

        function stopEvolution() {
            isPlaying = false;
            document.getElementById('playBtn').innerHTML = '‚ñ∂Ô∏è Play';
            
            if (evolutionAnimation) {
                clearInterval(evolutionAnimation);
                evolutionAnimation = null;
            }
        }

        function resetEvolution() {
            stopEvolution();
            document.getElementById('time').value = 0;
            document.getElementById('timeValue').textContent = '0.0';
            
            charts.evolution.data.labels = [];
            charts.evolution.data.datasets.forEach(dataset => dataset.data = []);
            charts.evolution.update('none');
            
            updateQuantumState();
        }

        function generateCreativeEnergyLandscape() {
            const ctx = document.getElementById('energyLandscape').getContext('2d');
            
            // Create a heatmap-style visualization
            const width = 400;
            const height = 300;
            const imageData = ctx.createImageData(width, height);
            
            let maxEnergy = 0;
            const energyValues = [];
            
            // Calculate energy landscape
            for (let y = 0; y < height; y++) {
                energyValues[y] = [];
                for (let x = 0; x < width; x++) {
                    const deltaU1 = (x - width/2) / (width/4);
                    const deltaU2 = (y - height/2) / (height/4);
                    const deltaU = Math.sqrt(deltaU1*deltaU1 + deltaU2*deltaU2);
                    
                    // Vary parameters for interesting landscape
                    const sigmaC = 1.0 + 0.3 * Math.sin(deltaU1);
                    const gamma = 0.5 + 0.2 * Math.cos(deltaU2);
                    
                    const energy = BoundaryCreativeEnergy.calculate(sigmaC, gamma, 0.3, 0.2, deltaU);
                    energyValues[y][x] = energy;
                    maxEnergy = Math.max(maxEnergy, energy);
                }
            }
            
            // Convert to colors
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const energy = energyValues[y][x];
                    const normalized = energy / maxEnergy;
                    
                    const pixelIndex = (y * width + x) * 4;
                    
                    // Plasma-like colormap
                    const r = Math.floor(255 * Math.sin(normalized * Math.PI));
                    const g = Math.floor(255 * Math.sin(normalized * Math.PI + 2));
                    const b = Math.floor(255 * Math.sin(normalized * Math.PI + 4));
                    
                    imageData.data[pixelIndex] = Math.abs(r);
                    imageData.data[pixelIndex + 1] = Math.abs(g);
                    imageData.data[pixelIndex + 2] = Math.abs(b);
                    imageData.data[pixelIndex + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Add contour lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            
            const contourLevels = [0.2, 0.4, 0.6, 0.8];
            contourLevels.forEach(level => {
                const threshold = level * maxEnergy;
                ctx.beginPath();
                
                // Simple contour tracing (simplified)
                for (let y = 1; y < height - 1; y += 5) {
                    for (let x = 1; x < width - 1; x += 5) {
                        if (Math.abs(energyValues[y][x] - threshold) < maxEnergy * 0.05) {
                            ctx.arc(x, y, 1, 0, 2 * Math.PI);
                        }
                    }
                }
                ctx.stroke();
            });
        }

        function generateNavigationData() {
            // Consciousness states in 3D space
            const consciousnessStates = {
                'Anxious': [2.0, -1.5, 0.5],
                'Calm': [0.0, 0.0, 0.0],
                'Focused': [-1.0, 2.0, 1.0],
                'Creative': [1.5, 1.0, 2.5]
            };
            
            // Navigation chart (2D projection)
            const navCtx = document.getElementById('navigationChart').getContext('2d');
            charts.navigation = new Chart(navCtx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Consciousness States',
                            data: Object.entries(consciousnessStates).map(([name, pos]) => ({
                                x: pos[0],
                                y: pos[1],
                                label: name
                            })),
                            backgroundColor: ['#ff6b6b', '#4ecdc4', '#45b7d1', '#ffa726'],
                            borderColor: ['#ff5252', '#26a69a', '#1e88e5', '#ff9800'],
                            borderWidth: 2,
                            pointRadius: 8
                        },
                        {
                            label: 'Navigation Paths',
                            data: [
                                {x: 2.0, y: -1.5}, {x: 0.0, y: 0.0}, // Anxious to Calm
                                {x: 0.0, y: 0.0}, {x: -1.0, y: 2.0}, // Calm to Focused
                                {x: -1.0, y: 2.0}, {x: 1.5, y: 1.0}, // Focused to Creative
                            ],
                            borderColor: '#9c27b0',
                            backgroundColor: 'rgba(156, 39, 176, 0.1)',
                            borderWidth: 2,
                            pointRadius: 0,
                            showLine: true,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Consciousness Dimension 1'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Consciousness Dimension 2'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.label === 'Consciousness States') {
                                        return context.parsed.label || `(${context.parsed.x}, ${context.parsed.y})`;
                                    }
                                    return `(${context.parsed.x}, ${context.parsed.y})`;
                                }
                            }
                        }
                    }
                }
            });
            
            // Capability ratios chart
            const capCtx = document.getElementById('capabilityChart').getContext('2d');
            const transitions = ['Anxious‚ÜíCalm', 'Calm‚ÜíFocused', 'Focused‚ÜíCreative', 'Anxious‚ÜíCreative'];
            const capabilityRatios = [1.2, 0.8, 1.5, 2.1]; // Example values
            
            charts.capability = new Chart(capCtx, {
                type: 'bar',
                data: {
                    labels: transitions,
                    datasets: [{
                        label: 'Capability Ratio',
                        data: capabilityRatios,
                        backgroundColor: [
                            'rgba(255, 107, 107, 0.7)',
                            'rgba(78, 205, 196, 0.7)',
                            'rgba(69, 183, 209, 0.7)',
                            'rgba(255, 167, 38, 0.7)'
                        ],
                        borderColor: [
                            '#ff5252',
                            '#26a69a',
                            '#1e88e5',
                            '#ff9800'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Capability Ratio'
                            },
                            beginAtZero: true
                        }
                    }
                }
            });
        }

        // Quantum measurement simulation
        function performMeasurement() {
            const result = currentState.measure();
            
            // Visual feedback
            const resultElement = document.createElement('div');
            resultElement.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(45deg, #667eea, #764ba2);
                color: white;
                padding: 20px 40px;
                border-radius: 15px;
                font-size: 24px;
                font-weight: bold;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                z-index: 1000;
                animation: measurementPop 1s ease-out forwards;
            `;
            
            // Add CSS animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes measurementPop {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            resultElement.textContent = `Measured: |${result}‚ü©`;
            document.body.appendChild(resultElement);
            
            setTimeout(() => {
                document.body.removeChild(resultElement);
                document.head.removeChild(style);
            }, 1000);
        }

        // Add measurement button functionality
        function addMeasurementButton() {
            const measureBtn = document.createElement('button');
            measureBtn.textContent = 'üéØ Measure State';
            measureBtn.className = 'btn';
            measureBtn.style.margin = '10px';
            measureBtn.onclick = performMeasurement;
            
            const evolutionControls = document.querySelector('.evolution-controls');
            evolutionControls.appendChild(measureBtn);
        }

        // Ternary logic gate testing
        function testTernaryLogic() {
            const gates = TernaryLogicGates;
            const testResults = [];
            
            for (let a of [-1, 0, 1]) {
                for (let b of [-1, 0, 1]) {
                    testResults.push({
                        a: a,
                        b: b,
                        tand: gates.TAND(a, b),
                        tor: gates.TOR(a, b),
                        tnot_a: gates.TNOT(a)
                    });
                }
            }
            
            console.log('Ternary Logic Gate Results:', testResults);
            return testResults;
        }

        // Enhanced consciousness scoring
        function updateConsciousnessMetrics() {
            const state = currentState;
            const probs = state.probabilities;
            
            // Advanced metrics
            const entropy = state.vonNeumannEntropy;
            const purity = state.purity;
            
            // Information integration (simplified Œ¶)
            const phi = calculatePhi(probs);
            
            // Global workspace integration
            const globalIntegration = calculateGlobalIntegration(probs);
            
            // Update display with enhanced metrics
            document.getElementById('consciousness').textContent = 
                (0.3 * entropy + 0.25 * phi + 0.25 * globalIntegration + 0.2 * (1-purity)).toFixed(3);
        }

        function calculatePhi(probabilities) {
            // Simplified integrated information measure
            // Based on the KL divergence between full system and parts
            const uniform = [1/3, 1/3, 1/3];
            let kl_div = 0;
            
            for (let i = 0; i < probabilities.length; i++) {
                if (probabilities[i] > 0) {
                    kl_div += probabilities[i] * Math.log(probabilities[i] / uniform[i]);
                }
            }
            
            return Math.max(0, kl_div);
        }

        function calculateGlobalIntegration(probabilities) {
            // Measure of how well information is integrated across states
            const maxProb = Math.max(...probabilities);
            const minProb = Math.min(...probabilities);
            
            // Higher integration when probabilities are more balanced
            return 1 - (maxProb - minProb);
        }

        // Real-time parameter exploration
        function setupRealTimeExploration() {
            const params = ['sigma_c', 'gamma_param', 'chi', 'lambda'];
            
            params.forEach(param => {
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.id = param;
                slider.min = '0';
                slider.max = '2';
                slider.step = '0.1';
                slider.value = param === 'sigma_c' ? '1.0' : '0.5';
                
                slider.addEventListener('input', updateCreativeEnergyParams);
                
                // Add to controls (if there was space)
            });
        }

        function updateCreativeEnergyParams() {
            // This would update the creative energy visualization in real-time
            // Implementation would depend on having the parameter controls
        }

        // Enhanced evolution with realistic Hamiltonian
        function createRealisticHamiltonian() {
            // Create a more realistic 3x3 Hamiltonian with interesting dynamics
            return [
                [1.0, 0.1, 0.05],
                [0.1, 1.5, 0.1],
                [0.05, 0.1, 2.0]
            ];
        }

        function calculateQuantumEvolution(hamiltonian, state, time) {
            // Simplified quantum evolution calculation
            // In practice, this would involve matrix exponentiation
            const eigenfreqs = [1.0, 1.5, 2.0]; // Diagonal approximation
            
            const evolvedAmps = state.amplitudes.map((amp, i) => {
                const phase = eigenfreqs[i] * time;
                return amp * Math.cos(phase);
            });
            
            return new TernaryQubit(evolvedAmps);
        }

        // Add keyboard shortcuts
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case ' ':
                        e.preventDefault();
                        toggleEvolution();
                        break;
                    case 'r':
                        resetEvolution();
                        break;
                    case 'm':
                        performMeasurement();
                        break;
                    case '1':
                        setPreset('focused');
                        break;
                    case '2':
                        setPreset('balanced');
                        break;
                    case '3':
                        setPreset('creative');
                        break;
                    case '4':
                        setPreset('meditative');
                        break;
                }
            });
        }

        // Initialize everything when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeApp();
            addMeasurementButton();
            setupKeyboardShortcuts();
            testTernaryLogic();
            
            // Add helpful tooltips
            addTooltips();
            
            console.log('üß† Ternary Quantum Consciousness Framework Initialized!');
            console.log('Keyboard shortcuts:');
            console.log('  Space: Play/Pause evolution');
            console.log('  R: Reset evolution');
            console.log('  M: Measure quantum state');
            console.log('  1-4: Set presets (Focused, Balanced, Creative, Meditative)');
        });

        function addTooltips() {
            // Add helpful tooltips to explain the concepts
            const tooltips = {
                'entropy': 'Von Neumann entropy measures quantum uncertainty',
                'purity': 'Quantum purity indicates how "mixed" the state is',
                'uncertainty': 'Three-way uncertainty product ŒîA¬∑ŒîB¬∑ŒîC',
                'consciousness': 'Integrated consciousness score combining multiple measures'
            };
            
            Object.entries(tooltips).forEach(([id, text]) => {
                const element = document.getElementById(id);
                if (element) {
                    element.title = text;
                }
            });
        }

        // Export data functionality
        function exportData() {
            const data = {
                currentState: {
                    amplitudes: currentState.amplitudes,
                    probabilities: currentState.probabilities,
                    entropy: currentState.vonNeumannEntropy,
                    purity: currentState.purity
                },
                timestamp: new Date().toISOString(),
                framework: 'Ternary Quantum Consciousness'
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], 
                                {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'consciousness_state_data.json';
            link.click();
            
            URL.revokeObjectURL(url);
        }

        // Add export button
        function addExportButton() {
            const exportBtn = document.createElement('button');
            exportBtn.textContent = 'üíæ Export Data';
            exportBtn.className = 'btn';
            exportBtn.style.margin = '10px';
            exportBtn.onclick = exportData;
            
            const evolutionControls = document.querySelector('.evolution-controls');
            evolutionControls.appendChild(exportBtn);
        }

        // Call this after DOM loads
        setTimeout(() => {
            addExportButton();
        }, 100);
    </script>

    <script>
    // --- Performance Budget: warn if slow (non-fatal) ---
    (function(){
      const B = {
        fp_ms: 2000,        // First Paint budget
        fcp_ms: 2500,       // First Contentful Paint budget
        longtask_ms: 100,   // Long task threshold
        total_long_ms: 600  // Total long-task time budget
      };
      let longTaskTotal = 0;

      // Paint timing
      new PerformanceObserver((list) => {
        list.getEntries().forEach((e) => {
          if (e.name === 'first-paint' && e.startTime > B.fp_ms) {
            console.warn(`[perf] FP ${e.startTime.toFixed(0)}ms exceeds ${B.fp_ms}ms`);
            markBadgeWarn(`FP ${e.startTime.toFixed(0)}ms > ${B.fp_ms}ms`);
          }
          if (e.name === 'first-contentful-paint' && e.startTime > B.fcp_ms) {
            console.warn(`[perf] FCP ${e.startTime.toFixed(0)}ms exceeds ${B.fcp_ms}ms`);
            markBadgeWarn(`FCP ${e.startTime.toFixed(0)}ms > ${B.fcp_ms}ms`);
          }
        });
      }).observe({ type: 'paint', buffered: true });

      // Long tasks (main thread)
      if ('PerformanceObserver' in window && 'PerformanceLongTaskTiming' in window) {
        new PerformanceObserver((list) => {
          list.getEntries().forEach((t) => {
            const d = t.duration;
            if (d >= B.longtask_ms) {
              longTaskTotal += d;
              console.warn(`[perf] Long task ${d.toFixed(0)}ms (total ${longTaskTotal.toFixed(0)}ms)`);
              if (longTaskTotal > B.total_long_ms) {
                markBadgeWarn(`Long tasks total ${longTaskTotal.toFixed(0)}ms > ${B.total_long_ms}ms`);
              }
            }
          });
        }).observe({entryTypes:['longtask']});
      }

      function markBadgeWarn(msg){
        const badge = document.getElementById('runtimeSelfCheck');
        if (!badge) return;
        badge.classList.remove('ok');
        if (!badge.classList.contains('error')) badge.classList.add('warn');
        const body = document.getElementById('runtimeSelfCheckBody');
        if (body) body.insertAdjacentHTML('beforeend', `<div>‚ö†Ô∏è ${msg}</div>`);
      }
    })();
    </script>
</body>
</html>
